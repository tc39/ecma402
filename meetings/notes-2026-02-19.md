# 2026-02-19 ECMA-402 Meeting

## Logistics

### Attendees

- Shane Carr - Google i18n (SFC), Co-Moderator
- Daniel Minor - Mozilla (DLM)
- Eemeli Aro - Mozilla (EAO)
- Jesse Alama - Igalia (JMN)
- Ben Allen - Igalia (BAN)
- Yusuke Suzuki - Apple (YSZ)
- Henri Sivonen - Mozilla (HJS)
- Philip Chimento - Igalia (PFC)

### Standing items

- [Discussion Board](https://github.com/tc39/ecma402/projects/2)
- [Status Wiki](https://github.com/tc39/ecma402/wiki/Proposal-and-PR-Progress-Tracking) -- please update!
- [Abbreviations](https://github.com/tc39/notes/blob/master/delegates.txt)
- [MDN Tracking](https://github.com/tc39/ecma402-mdn)
- [Meeting Calendar](https://calendar.google.com/calendar/embed?src=unicode.org_nubvqveeeol570uuu7kri513vc%40group.calendar.google.com)
- [Matrix](https://matrix.to/#/#tc39-ecma402:matrix.org)

## Status Updates

### Updates from the Editors

BAN: No updates; I've been focused on proposals.

RGN: No updates… we're expecting a PR soon for Temporal stage 4.

PFC: It's already there!

BAN: And we'll be adding Intl Era Month Code, maybe to the same PR.

PFC: Adding them in the same PR seems simplest.

### Updates from the MessageFormat Working Group

EAO: Has been fairly quiet. Have been on vacation for most of January

### Updates from Implementers

https://github.com/tc39/ecma402/wiki/Proposal-and-PR-Progress-Tracking

HJS: Shipped new spec behavior for “islamic” identifier, not sure where we are with “islamic-rgsa”

SFC: Part of intl era monthcode.

### Updates from the W3C i18n Group

EAO: No way to participate there much this calendar year. Earlier discussions about getting feedback from them on import text proposal and the changes there. Nothing really conclusive ECMA-402 related.

## Proposals and Discussion Topics

https://github.com/tc39/ecma402/projects/2

### IntlMV limit

https://github.com/tc39/ecma402/pull/1022

SFC: I’ve asked for feedback on what limits should be, TG2 conditional approval, defer to TG1 on bounds, TG1 uncertain, what you’ve put in the PR is fine, so we have approval from TG1 to implement bounds listed in this PR. May need to fix comment. This was one proposal for bounds, maybe not best bounds, are these the ones we want to move forward with? If so, will respond to WH’s comments and continue with PR

DLM: If you follow up on WH’s comments, looks good to us

EAO: Do ICU libraries have issues with these bounds?

SFC: Both ICU and ICU4X are good with these bounds. Main catch / only hesitation: right now the effective bound is about 400 sig digits, not possible to have more than that, not clearly specified because it’s sort of a 3-way bound before you actually get there. Have to combine bound. This makes it 10,000 sig digits, increas requirement. 400 already a lot, requires allocating vector of digits, same deal here, vector can be a bit bigger, only real hesitation we have, only thought is lower bound on sig digits, 500, similar to now. TG1 seems to prefer what’s written up, seems easily explainable/implementabl.

DLM: quick Q, should asked earlier, are implementations allowed to support larger values?

SFC: This is currently a maximum, makes maximum bigger, big enough to support (for example) future Decimal type.

DLM: In future we could increase again if necessary, but not decrease

SFC: Right, we can increase if we want, should be webcompat, decreasing it may or may not be webcompat, we’d have to check

DLM: Is Decimal the motivation? 

SFC: Motivation was – initial impulse was increase it when we have Decimal, but got feedback from WH in context of different proposal, he thinks that it might not be webcompat to increase bounds, wants to increase now rather than later so that we don’t have to worry about webcompat later. Conclusion: fix WH comment, other than that land as-is, if any additional feedback before landing re: exact bounds, will come back to TG2 next month with updated PR. Hopefully we get this into 2026.

#### Conclusion

Proceed with the PR as written, after addressing Waldemar's feedback. Come back here if it changes.

### Intl locale info

SFC: We have PR request open, reached Stage 4 in November meeting? Posting note: after merging, merge PR 92. PR 92 resolved, it’s been landing, no open issues. What else do we need? Another review from editors and then we’re good?

### Sync on ES 2026 status

Open PRs: https://github.com/tc39/ecma402/pulls

Milestone: https://github.com/tc39/ecma402/issues?q=is%3Aissue%20state%3Aopen%20milestone%3A%22ES%202026%22

SFC: No normative PRs, the ones up are draft, Intl MV limits, which editorial PRs do we want to get into ES26? 

RGN: Haven’t covered Intl MV limits, does this cover both range and precision?

SFC: Yes. Increases limits, explicitly limits sig digits. Previously limits on range, sig digit limits were not explicit, now they’re explicit. Previously indirectly specified by means of sig digits limit on formatter

RGN: If I have way too manydigits, will that push it – will all digits be considered when resolving ties?

SFC: Floats not an issue, for decimals out of range we truncate. There is double-rounding, but first rounding is a truncate

RGN: Probably doesn’t matter much when we’re dealing with this kind of variation. The determinism is valuable regardless of how it’s deterministic. Re: editorial ones, we want to get in as many as possible but some need to respond to review feedback. 

SFC: Will let RGN and BAN sync on process for making sure editorial is landed before cutting ES26. We don’t want to cut ES26 w/o time to review editorial PRs, want to cut the branch when we cut the branch. Feb. is many things, one of them is getting ready for ES26.

### Intl keep-trailing-zeroes

https://github.com/tc39/proposal-intl-keep-trailing-zeros/issues/9

https://github.com/tc39/proposal-intl-keep-trailing-zeros/pull/10

EAO: Issue 9 is just saying it’s ready, pending issue 10, also refers to fact that test262 coverage updated to match what’s in PR 10. Addressed RGN issues, and in test262 PR, think I’ve answered SFC questions on PR 10

SFC: Will take another pass at PR 10. 

EAO: Provided that I get approvals on that PR before stage advancement deadline, will be asking for stage 3 on this. 

SFC: One more week until that, will revisit my review, RGN also reviewer. Want to ask for Stage 3? 

EAO: Pending PR, yes

RGN: +1, will go over spec text, am in favor of advancing

SFC: Pending spec review, in favor. Any other thoughts on stage 3? YSZ, did you have a chance to look at this? Want to review spec pre-Stage 3

YSZ: I'd like to check; the overall design based on discussions, overall I don't have concerns. I'll recommend after checking the final spec deeply.

EAO: I also suggest looking at the Test262 PR which covers the cases for how this is supposed to work.

#### Conclusion

Approval from TG2 for Stage 3, pending final reviews from RGN, SFC, YSZ.

### Amount update

EAO: Let’s start with PR 81

https://github.com/tc39/proposal-amount/pull/81

...

EAO: Further from there, you can also define a usage, depending on what you’re using it for the usages are different for different locales, there are fallbacks, but also specific ones that are supported. 

EAO: Unit conversion: Basically always cast the type of the Amount into a Number, then possibly multiply/divide to get a Number result. Basically apply same digit options as in Intl.NumberFormat, default would be the same as Intl.NumberFormat. minimumFractionDigits 0, maximumFractionDigits 3, can customize up to precision that Number is allowing for. At least the locale and usage parts of this are 402 features, whereas the rest of this could well be defined in 262 text, which would then need to introduce a normative reference on this one xml file. Spec text not written, this PR is just for the README to agree on what we want to do with general direction before specifics.

RGN: +1, in general I think it would be good for 262 to take on that narrow normative reference.

EAO: This is technically not a TG2 proposal, but it has this dimension of needing to have some aspect of this text, especially for unit conversion, must be 402. Provided this is supported, prepared to present all of amount for stage 2 at next plenary, see if TG1 likes this too. 

EAO: Preferred solution .convertTo being 262, locale options defined as extension in 402. Meaning of what’s in options bag and how locale is handled in 402.

RGN: It’s a 402 override, in that 262 wouldn’t even read locale property, 402 would, same committee specifies both, we’d have internal operation that would be entirety of 262 and used by 402 as reference

SFC: for .toLocaleString 262 implementation is one line (call .toString), 402 has interesting logic, currently 262 has some logic and 402 has additional, prefer 262 is 1-liner that calls AO, 402 cals overrides

EAO: Spec-text wise it involves copying/moving text for defining min/max fraction and sig digits are handled from 402 to 262. Essentially a spec-implementation detail.

SFC: another thought, for stage 2 purposes say default is NumberFormat default, can discuss but not a Stage 2 issue. Notice I don’t see an option that’s number of sig digits in input.

EAO: This is for .convertTo, so basically determine # of sig digits that input has, pass that in as min and max sig digits

SFC: You can do that, but the Amount type also knows how many sig digits it has.

EAO: Not necessarily, good segue into discussing PR 81.

EAO: PR 81 started out as smaller change than currently, the fields and methods on an Amount instance, it was, we then had a discussion including OFR from V8 team who previously had concerns re: Amount, might force implementations to be unnecesarily serializing/parsing value, what we’re proposing in PR 81 we make it so that when constructing Amount w/ BigInt, Number, or decimal string, we keep BigInt and decimal string, if you construct with value 42, we end up with type: number, but if you provide fraction digits or sig digits in constructor, you end up with numeric string representation (that you can still cast back into a Number). This change also drops the .fractionalDigits and .significantDigits accessors, also dropping the 

EAO: providing an amount that is performant and supports the use cases that we have on it (formatting, interchange), also should work for those purposes and it adds a minimum of other features that we could imagine an amount having, but which are not actually necessary for the use cases that we imagine for it, that’s why I refer to the previous conversation as a segue, if we accept PR 81 we would be dropping the Amount instances retention of sig digits /fractional digits on the instance, which is what SFC was referring to. Technically not a 402-scoped change, so will need to be presented to TG1 and will need spec text so that we could seek to advance Amount to stage 2 w/ this proposal

SFC: If input type is Number or BigInt, it can calculate when it does the conversion. But if you call .convert that triggers 

RGN: how many sig digits are in value 100?

SFC: We could define it as 1 or 3, I’d say we define it as 3

EAO: Other cases where number is result of conversion were it has a precision much more than user thinks it is

SFC: Out of scope for amount, if result of binary arithmetic operation we have 15 sig digits, if you choose not to provide when construction, well, you get what you ask for.

EAO: TG2 part of story, barring input from others, 

EAO: Amount we end up with is an object with a value field that has a Number/BigInt/numeric string, what we support in NumberFormat.format, also has a unit string field. If we go with this Amount is an obvious intl unit format thing, doesn’t access Amount internals but just these public fields.

SFC: And if always construct with sig digits / fractional digits, it’s always a string?

EAO: Correct. Retain the type if you don’t mess with it, if you mess with it it’s represented as a decimal string.

SFC: This is on my list of things to give a thorough review, overall shape covers all the needs, if it can reach consensus that’s a good thing. I had minor things, like thing about default precision for convert, that’s something that can be resolved at stage 2, many tradeoffs with all options. 

EAO: Proposal now is that Amount.toString would not represent options, numeric value of string, in square brackets unit identifier or [] if no unit. Intent is to make sure that this .toString representation is regular but also ensure that it does not parse as a Number. If you have in JS code Amount + Amount, this will always do string concat rather than numerical casting/addition.

SFC: Good change. 

EAO: Request for reviewer to prioritize these two README prs, we need to have spec text for stage 2 and we can’t have spec text until agreement on these. 

SFC: Will prioritize over intl-trailing-zeroes. Will aim to get both done before plenary, but this one first so we have time to spec it.

### Intl Unit Protocol Handling conflicting units #3

https://github.com/sffc/proposal-intl-unit-protocol/issues/3

SFC: essentially about unit/Amount proposal. Split to talk about each chunk separately. Interesting/compelling – takes a unit, enough 402-specific to not bog down Amount with additional discussions. One question: Handling conflicting units. Question that Amount would have to answer, but we can answer it in this context. Not Amount-specific, has anything to do that takes the options bag. So, what do you do with this code: 

new Intl.NumberFormat("en", {
    style: "unit",
    unit: "meter",
}).format({
    number: 1234,
    unit: "kilometer",
})


SFC: exact syntax needs to be discussed in Amount. Align “number” with “value” from Amount? But if we have one unit coming in here and another that’s coming in there, what do we do? Throw a RangeError? Assumed that would be the uncontroversial solution, people at TG1 in Tokyo brought up alternate solutions, one of them is unit in format function implicitly overrides constructor, other is implicit conversion, other give the user the option of what they want. So we have option called overrideUnit or something, additional option passed to format function to pick behavior you want. EAO replied either throw error or convert, and should not convert until/unless unit conversion supported by 262 functionality.

EAO: Position is that if we get Amount to go forward with .convertTo, then if defining a unit on the Intl.NumberFormat instance does unit conversion provided that it’s a valid pair of units to convert. If we are introducing Amount with Intl part also supporting usage, interesting to consider whether this proposal ought to be one adding usage, as in Intl.NumberFormat constructor option.  Amount with set unit, format with Intl.NumberFormat instance saying formatting with this locale and this usage, it’s majority of Smart Units.

SFC: That’s reasonable, especially if we have unit conversion functionality, doing implicit conversion is fine and good / maybe expected. If Intl Unit Protocol advances first, start with RangeError and then add implicit convert later.

RGN: +1

JNM: Like the idea of keeping option open until add additional functionality. 

### Intl Unit Protocol Interop with Amount #2

https://github.com/sffc/proposal-intl-unit-protocol/issues/2

SFC: We still have question of how we want interface to look. Preference for read two fields (number or value, depending on name in Amount), if you don’t use Amount object this is easy to implement with object literal, get both benefits from it. Alternatives is using Symbol functions, more like Iterator protocol, can’t really do with object literal, advantage of this is that it doesn’t require exporting these properties on the object, implementing with functions makes contract on those functions much more clear, can’t think of clear advantage beside that. JS supports frozen objects and readonly fields, if you read the fields does that require them to be mutable? I don’t think so, because JS has readonly fields, if you want to implement this as a class you could have getters, still have class-based approach that doesn’t have fields, exposes as getters, JS already has capability to make this ergonomic even w/ class amount. Different from EAO first proposal which uses string for everything, now that we’re splitting string and unit that goes well with intl unit protocol. 

EAO: Yes.

#### Draft conclusion

Intl Unit Protocol should use object bag approach, seems like it’s compatible with everything else.

### Editorial: Refine calendar implementation notes

https://github.com/tc39/proposal-intl-era-monthcode/issues/115

SFC: (discusses open comment)

HJS: Does Reingold align with the Iranian government data?

SFC: By my recollection, I think not, but I need to check.

HJS: I think Microsoft uses Reingold but not sure.

SFC: Needs tests for this, not using polyfill since polyfill might be wrong. Need tests for Iranian data

PFC: Implicitly covered already. 2025 government data doesn’t line up with Reingold data, we have tests for that.

SFC: Need coverage equivalent to “chinese”

PFC: Makes sense

### Editorial: Inline CalendarDaysInMonth and CalendarMonthsInYear at call sites#116

https://github.com/tc39/proposal-intl-era-monthcode/pull/116

PFC: I think the AO is valuable. I prefer closing the issue.

SFC: Now that I've seen the inlining, I agree that the AO is better. I think demonstrating that CaledarDateFromISO slots align with the prose is valuable. So I think I prefer going back to Jesse's first version of the PR.

### What is the most helpful form of the PlainMonthDay reference year table? #114

https://github.com/tc39/proposal-intl-era-monthcode/issues/114

PFC: The table for chinese/dangi reference years is correct, and is what we want implementations to standardize on. Question is: is this the easiest format for implementations to consume? Also, tables for other calendars? Other calendars do not have the issues that East Asian lunisolar calendars have. Looks like ICU4X works in calendar-space, spec is written in ISO-space, but also ISO-space is how the data model is described and might be more appropriate for that reason. Worst case: do nothing and that’s fine.

SFC: already commented in issue, tradeoffs exist, pros and cons. Preference for putting table in spec for all calendars that we have, but not strictly necessary, since other calendars don’t have as many edge cases as chinese/dangi. Get feedback from YSZ or DMN on this one? Not necessarily right at this moment, I assume they have also had to deal with this problem, it seems like this lands in the part of the firefox code that’s not in ICU4X, feedback from anba may be useful.

PFC: I thought Firefox was using ICU4X for this?

SFC: Possibly not this part, Firefox has been shipping this before this.

YSZ: I’ll take a look

PFC: If comments, please comment soon so we have time to get it into Stage 4 PR, if editorial change to change the format we can do it after it lands in the spec. If you want comment reflected in stage 4, do it soon, otherwise we can discuss this post-stage-4

SFC: What is currently in the spec is okay enough for stage 4, not so broken if we don’t fix it, fine to fix later, most important problem already solved (chinese/dangi). If we land this after spec lands it’s … fine… is how I feel about it.

PFC: That’s my feeling as well. 

### Normative: Temporal stage 4 #1044

https://github.com/tc39/ecma402/pull/1044

PFC: Any additional questions re: Temporal Stage 4 PR?

PFC: Will add Intl Era Monthcode to this PR, since it makes sense to merge them together

SFC: Why deleting DurationFormat stuff?

PFC: Many of these things are moving into 262 with Temporal.Duration.

SFC: Makes sense. .toLocaleString definitions…

PFC: AsciiUppercase and lowercase added to 262, 

RGN: I have editorial PR for presentation of rounding modes, maybe I should move that over into your 262 PR. 

SFC: we had discussed how to do that, and came to agreement on that. I think we just haven’t landed it yet – needed to update PR.

RGN: We have a path forward not reflected in current state. Given this–

SFC: – for AOs that have to move, maybe in standalone PRs instead of big Temporal PR.

PFC: Yeah, probably the main bottleneck is 262/402 editor time/attention. If that makes it easier, we can do that. 

RGN: Allows for comprehensible sequencing. If this PR adds the new text and moves operations, we can’t land it, but if it adjusts the text independent of moving the operations, we  could. 

PFC: Slightly complicated because 262 editors haven’t made up minds re: whether Temporal goes straight into 262 or own document, some things need to move to 262 regardless (GetOption, etc).

RGN: Yes, operations come in independent of use if they’re willing to bend rules on convention.

SFC: Most are independent, roundingMode and getOption both independent.

RGN: There’s a convention amongst 262 editors to not have operation in 262 unless used in 262, sequencing in this much benefit from bending this rule – add operation that’s expected to be used, but not yet.

EAO: I don’t think that holds for importJSON, there’s an AO that is only effectively called in html spec, just an observation aside from what’s concerned here.

RGN: We can move on 

SFC: Any comments?

RGN: Even cursory review was valuable. 

PFC: Good to know!

### Intl Era Month Code update: ready for Stage 4? #119

https://github.com/tc39/proposal-intl-era-monthcode/issues/119

BAN: (goes over open PRs)

SFC: It seems very fast, since this just only got Stage 3 at the last meeting, but I can't see any reason why this isn't ready for Stage 4

RGN: Seems to be ready!

DLM: Fine from my point of view

YSZ: +1

#### Conclusion

TG2 approval for Stage 4, pending open PRs

### 402 issue 1043: 

https://github.com/tc39/ecma402/issues/1043

PFC: This is something that Anba pointed out. As I understand, data sources for date time formats when using dateStyle and timeStyle comes from different data source in CLDR than when constructing DateTimeFormat object with options for individual units. When you say DateTimeFormat with year: 2-digit and month: long, the format matcher algorithm going through available formats and picking one, if you use dateStyle: long for example, you’ll get a different format. What I understood from Anba is that some of the dateStyle/timeStyle formats are not ones that can be returned from the matcher, this is technically all implementation-defined, so it’s not specified, but in practice you can format a date with dateStyle that you cannot achieve with formatting the date with same individual year/month/day options. I think this is probably an inadvertent consequence of how data is structured in CLDR, and doesn’t seem desirable to me. One thing we could do is say in the spec that DateTimeStyleFormat AO must return a Format Record that also could be returned by [Basic/Best]FitFormatMatcher. Thing to handle at CLDR not 402.  Other things we could do on the spec side, refactor the spec data model for the locale data stored in DateTimeFormat, less sure how to do it, that’s why I opened this issue for the discussion on this. 

EAO: My understanding is that the data structure in CLDR around this is because it’s a function of how what data and how it’s being collected, coming from the representatives of each locale in the polling that Unicode does about this regularly. I would find it weird for us to require this, given that the data that’s preferred by each locale is defined by the people of that locale, and in many cases because the fields used for dateStyle and timeStyle depend on the locale, so if you were to enforce the representation to go through field options, this would – you would need to use different field options for each locale you’re formatting to, feels like in implementation this would be problematic, also I don’t understand what user problem this is solving. It’s weird and a little surprising, but because the formatted output is supposed to be considered opaque, why should we impose this restriction on that opaque value?

SFC: problem is patterns not reachable. DMN implemented this in ICU4X back in the day. Issue in CLDR to do better job of linking them. Not sure 100% alignment. One thing to note is that when we introduce dateStyle/timeStyle ZB made argument that locale should choose what fields are appropriate to them, dateStyle/timeStyle allows locales to do this, in practice I’ve not seen any locale that uses different set of fields, except maybe turning era on and off. In terms of year/month/day/weekday, those fields are always determined by length (i.e. dateStyle: long uses same set of fields). eraDisplay to decouple era from being a field? ICU4X has implemented something in that area, it’s worked well there, treat era problem as different from field selection problem, same goes for time (long/short/medium/full has same fields). CLDR has had 20 year to change this, no one has changed it, only seen one comment (from Rabban?) saying different defaults might have different rules for time zone, which would impact timeStyle: long and timeStyle: full. Presence of time zone does not get impacted by that. Wait for CLDR to resolve issue

EAO: you’re saying set of fields is consistent, but also separators between fields can be different in dateStyle/timeStyle compared with what you’d get with field options.

SFC: given set of fields consistent, we can get to point where other separators are consistent between dS/tS and components.

EAO: What are benefits?

SFC: If you create DateTimeFormat and put in a JS Date or different shapes of Temporal date, format you get out will look consistent. Right now if you pass Temporal date into DTF object configured with wrong field set, it will re-resolve pattern and pattern could look very different. Other problem is longstanding that is partially but not entirely resolved [missed]. Singular date and range date have totally different formats, since one uses components and other dS/tS

EAO: Not completely convinced those are valuable enough, but don’t have strong opinions in general. 

SFC: I think it is something – this is just something we _could_ do, no technical reason why we can’t. Should we do it is more questionable, think we should keep issue open and wait for CLDR 1993 to resolve and then revisit. Don’t think we should enforce it before implementations already do it, if we choose to enforce it later I don’t see a technical reason why we shouldn’t.

EAO: Related question: Do we in 402 enumerate expected fields when using specific dS/tS options.

SFC: Yes, you can pull out of resolvedOption

EAO: no, in the spec. Does spec say when you expect to see hours/minutes or seconds?

SFC: Maybe we should do that as part of 1043. Make dS/tS code path and have it use component spec code path.

EAO: Even if that produces suboptimal results compared to status quo?

SFC: Well, that’s after we get CLDR to align. To be clear: when you have dateStyle/timeStyle you still need CLDR data for widths of fields, so that’s still implementation-defined data. Part of CLDR 1993 fills that in. Example: in Japanese locale, pattern you get out of dateStyle: long has numeric month, but numeric month has a kanji for year/month/day, but numeric year/month/day. If you take it back put in component bag reformat the pattern you get the short format. Way to get the correct format is to ask for month: short, not month: numeric, then you get correct pattern. But you can’t take lengths of fields in the pattern. 

### Items for TG1 Agenda

- Intl Era Month Code for Stage 4
- Amount maybe for Stage 2
- Intl Unit Protocol maybe for Stage 2
- Keep Trailing Zeros for Stage 3
