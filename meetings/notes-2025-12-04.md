# 2025-12-04 ECMA-402 Meeting

## Logistics

### Attendees

- Shane Carr - Google i18n (SFC), Co-Moderator
- Ujjwal Sharma - Igalia (USA), Co-Moderator
- Ben Allen - Igalia (BAN)
- Eemeli Aro - Mozilla (EAO)
- Louis-Aimé de Fouquières - Invited Expert (LAF)
- Philip Chimento - Igalia (PFC)
- Henri Sivonen - Mozilla (HJS)
- Frank Yung-Fong Tang - Google i18n, V8 (FYT)
- Richard Gibson - OpenJS Foundation (RGN)

### Standing items

- [Discussion Board](https://github.com/tc39/ecma402/projects/2)
- [Status Wiki](https://github.com/tc39/ecma402/wiki/Proposal-and-PR-Progress-Tracking) -- please update!
- [Abbreviations](https://github.com/tc39/notes/blob/master/delegates.txt)
- [MDN Tracking](https://github.com/tc39/ecma402-mdn)
- [Meeting Calendar](https://calendar.google.com/calendar/embed?src=unicode.org_nubvqveeeol570uuu7kri513vc%40group.calendar.google.com)
- [Matrix](https://matrix.to/#/#tc39-ecma402:matrix.org)

## Status Updates

### Updates from the Editors

BAN: No meaningful update today.

USA: There was one tiny open editorial issue, which I merged. It was by Anba earlier today.

#### "languageDisplay" can be undefined in Intl.DisplayNames.prototype.resolvedOptions #1037

https://github.com/tc39/ecma402/pull/1037

USA: Here, this is an oversight that we had in teh INtl.DisplayNames proposal. Basically, all the resolved options of the DisplayName proposal are resolved, except for langaugeDisplay which remains unset if it is not set. This slot therefore can be undefined if it is not passed in the options. Anba’s editorial change just accounts for the case where languageDisplay can be undefined, which is when none is provided in the options. This is an editorial change, since it is not my understanding that anybody has implemented this behaviour, but to clarify I wanted to discuss with the implementers. FYT?

FYT: This is… this is not an editorial change, right?

USA: I changes normative behaviour. We’re classifying this because no one has implemented the spec as-is, and so it does not change web reality.

FYT: That’s not a definition of normative vs editorial. Normative just means changing observable behaviour. 

USA: You’re spot-on. The argument here is that no actual observable change has happened, because this is a spec bug that is already implemented in the way that it is being implemented now, because it is the only way you can implement it.

FYT: This is not the only way to implement it – I don’t think this is editorial, I think this is a normative change. I’ll have to double-check, but this is not an editorial change, this is normative for sure.

USA: The argument is that it could be normative or editorial based on the question you asked earlier. If it’s actually implemented per the spec it’s a normative change, but—

FYT: Web reality has nothing to do with normative vs editorial. Web reality has nothing to do with normative. 

PCO: I think the – customarily the definition has been that if a change is – if there’s an obvious mistake in the spec that does not match intentions and which have not been implemented in that way, it’s — the definition that TG1 uses is more flexible than what FYT says, based on intent on whether it’s possible to implement the spec as written.

FYT: Is anything not possible?

RGN: FYT’s definition of what constitutes a normative change vs an editorial one is correct, but that’s not the end of the story. Specifically, what is happening here is a spec bug. The spec is internally inconsistent if it asserts that a specific value cannot be undefined, but it is here undefined. This is at a level beeyond editorial/normative, because it’s impossible to implement without this change. Classifying it as normative is inappropriate. Classifying it as editorial is something that we do by convention, though it could be in a distinct category related to spec bugs.

USA: I pasted the 262 version of the assertion in the spec

> A step that begins with “Assert:” asserts an invariant condition of its algorithm. Such assertions are used to make explicit algorithmic invariants that would otherwise be implicit. Such assertions add no additional semantic requirements and hence need not be checked by an implementation. They are used simply to clarify algorithms.

USA: That assertion failing in this algorithm is indicative of a spec bug. Here, the assertion that languageDisplay is not set to undefined is failing in the case that there is no languageDisplay defined in the options

SFC: Since it’s an assertion that fails, it’s a spec bug. We really should have a separate category for this that’s between editorial and normative. We could suggest to the 262 editors that we make a third category between editorial and normative. I’ve looked at the change a bit and it makes sense to me, I agree with landing the change. 

USA: Before we move on to the next one, the two most important questions here to make sure we’re on the right side of things are 1: was this ever implemented different from the suggestion by anba? If so let us know, because that makes things more complicated. 2: if — actually, question 1 is the most important. Apologies. The other question is do any of us disagree with the solution proposed by anba, or disagree that this isn’t how we imagined this would work. If so, that’s complicated because it would indicate that it doesn’t match the consensus we had already. Barring that, it is clear that this is a spec bug – matches the consensus of the group and also matches web reality

EAO: So we do have in the “how we work” repository definitions to normative and editorial, with normative “impacting javascript behaviour in some way” – observable, someone can observe the change. If no one has implemented this the other way then no one can observe the change, and it is therefore editorial.

### Updates from the MessageFormat Working Group

EAO: It’s been relatively quiet, we have specified :percent :currency and we have decided to drop the u:locale option. We are continuing to figure out what to do with unit formatting and DateTime formatting.

SFC: I think that we’re thinking a lot about how the Message author specifies their unit, specifically unit quantity(?), useful for units in Amount. 

EAO: With a note that the context we are covering in MessageFormat is for NumberFormat ultimately. Going ahead NumberFormat and PluralRules are not the only places where we’re interested in something like an Amount intrinsic or an Amount protocol.

EAO: One other detail… The message resource specification work has been picked up for incubation by the W3C i18n working group, so the research on how a whole pile of messages is going to work is going to continue largely under W3C rather than Unicode

### Updates from Implementers

https://github.com/tc39/ecma402/wiki/Proposal-and-PR-Progress-Tracking

FYT: We have the variants in the staging in PR 960, it’s in the V8 staging, but there is delay because they’re requesting fuzzing code that I haven’t been able to write, it’s not flipping until probably later.

SFC: Temporal got delayed a release cycle based on the fuzzing code we had to write, Manish wrote a lot of it, it’s good to have the fuzzing code but it just takes time. 

FYT: November V8 shipped some of PR 143 – relatively new. One thing I wonder is last time TG1 reached consensus with staging for Intl.Locale, 

### Updates from the W3C i18n Group

SFC: EAO gave us a preview about MessageBundles, also at TPAC. 

EAO: I hosted 3 breakout sessions at TPAC, for the W3C i18n group but for a wider audience as well. Meeting with WHATWG about DOM [?] resources, which is a lot of reason why the i18n working group is interested in getting resources for incubation, so there’s a lot of work ahead for me in that space as well. Separate from that HJS hosted a breakout session on en-ZZ. Next steps on that is raising it at CLDR TC. One interesting detail of discussion of that at w3c is considering – currently it’s formulated as being “US English with standard measures”, but possible way to see it as “source english” with standard measures. The English used by the developers originally writing the thing being localized, for example a UK developer writing UK English would have en-ZZ using standard measures and UK spelling. This is something that is not fixed for the en-ZZ proposal, but might be considered further and HJS has opinions.

HJS: This was brought up, but I think this goes… it's against the idea of it being enabled by default. If it is enabled by default by some heuristic then we can’t change the spellings that users see, because then all the users using US english because they actually want it are going to be unhappy if we by some automatic heuristic change the UI strings. So although this was brought up it does not seem like a good way forward.

EAO: We’ll have to discuss this further, but not in this context.

EAO: I also presented on the HTML amount element. Response to this element was even more positive than we expected, and a specific takeaway from that is that an HTML amount element would be providing some amount of unit conversion out of the box for display to users at least, so it makes it much more interesting to consider sooner rather than later incorporating unit conversion into the JS Amount proposal, or bringing it into 262, to make it easier to implement unit conversion in Amount / html amount that they could rely on without having to abuse systems available elsewhere.

SFC: For en-ZZ you said you wanted to consult with CLDR on that, are you planning to join that, do you have a ticket open for it, are you on the agenda, what’s the next step?

EAO: I have not had time yet to figure that out. Are you happy to helping drive this conversation? I’m much more closely involved with the workings of CLDR than most people in this call, so what would be helpful for me is if you could write up the specific ask in a Jira ticket, I’ve definitely done my share of coming to CLDR with a problem, and the response has typically been nodding heads this is a problem how do you propose fixing it? If you come in with a proposed solution it’s easier to get it usefully on the CLDR agenda.

EAO: I’ll get to that soon, unless HJS gets to it sooner. 

HJS: The explainer already has a list of things of what would need to be done, so that’s a good starting point.

## Proposals and Discussion Topics

https://github.com/tc39/ecma402/projects/2

### iso8601 as DateTimeFormat calendar #1036

https://github.com/tc39/ecma402/issues/1036

PCO: I opened this issue based on a question from SFC. The question here is what we want to do about having iso8601 as the calendar of  DateTimeFormat object, and is the current behaviour actually what’s decided? If it’s not the case, is it webcompat to remove it? 

SFC: EAO’s comment about this spec is – if we do currently state that one of the available calendars for DTF is iso8601, I wonder when this text was added, if we assume that 

EAO: my comment includes that information

SFC: Two comments. If we were to say that Intl.DateTimeForamt doesn’t support the calendar, what should the behavior be? If it does support the calendar, I agree with EAO’s statement that we should specify that it does a specific behaviour. We shouldn’t rely on what comes from CLDR, since CLDR is a mess on what to do with this calendar – it has changed a lot, and they haven’t really decided how it should behave. There are some questions here: if we do do this, is the iso8601 calendar just for the date? How about the time? Are we doing timezones? How does that interact? So there are still some ope. questions here. In general it would be nice to move in the direction of stable formatting. I was hoping that iso8601 would be a way to get back to stable formatting. I don’t think it would be a webcompat issue to have it fall back to the locale calendar. One reason was that if the temporal non-iso8601 locale calendar is (?) a funny case to try to resolve.

USA: A couple of points that go in the same direction. Short version: I agree with EAO.  1) we already have this kind of behaviour if not for calendars then clearly for timezone, with support for UTC in the same constructor, and I would argue that this would be along similar lines, this is the point of the iso8601 calendar. To respond to SFC’s comment on stable formatting, this is kind of the same thing. Whether or not we do anything special for stable formatting, specifying iso8601 puts across your intent to stably format a date and time. Also, I think with things like stableformatting or what we’re doing here, we’re actually improving things specifically — my understanding is that it really helps and it unifies code paths, in some cases you might have diverging code paths for all other calendars, and if it can save that, or allow certain applications in an intl-light context, that increases the [something] of intl-compatible code.

PCO: If we’re making it fall back to locale default calendar, that’s much more likely to be webcompat. What would not be would be to throw if the formatter is given that calendar. 

EAO: Currently with the iso8601 calendar selected you get iso8601 formatting with times as well, so long as you’re not messing too much with what you’re aiming for. The tz identifier does appear to be localized, as is weekDay, and if you ask for a long month name that is localized. But if you ask for a long month name you’re breaking so far from the iso patterns that you’ll get something relatively closer to what the locale works with.

SFC: Looking at my copy of Chrome, I’m not seeing iso8601 formats. I think it’s good to specify that iso8601 uses iso8601 formatting, but CLDR doesn’t have this data on how to use it consistently across locales. There’s a ticket in CLDR that the iso8601 calendar should behave exactly like gregorian, but with year month day ordering. That’s not what we’re seeing, that’s the CLDR proposed behaviour that they rolled back. So there’s a big pile of problems here. I’m worried about the implementability of this, since we could spend a whole miniproposal just specifying what the behaviour should be, and then who’s going to implement it because it’s not implemented by ICU. I can make ICU4X implemented, but how are we going to scale that? If we remove iso8601 and fall back to locale default, we can at a later date add it back in once we have the resourcing to implement it in engines.

USA: I just checked, Firefox does format it with the hyphens, which is more correct, but it’s not great for any of us. I think this is what you meant by CLDR being unclear. This is a terrible situation, personally my opinion is that iso8601 should be a special case in our spec, so that we can do something like .toString for the temporal types or get the same result for a date object as well for consistency, but make sure that when someone specifies they need the iso8601 calendar, or temporal’s defaults if someone ends up with iso8601 calendar, then formatting it results in the iso8601 format. It’s not a local format, but it is well-known and so should be respected.

EAO: The divergent behaviour is weird, especially since firefox adopted 78 a few days ago, so the behaviour I’m getting in firefox nightly should be the same as what you’re getting in Chrome, which clearly it’s not. This is weird.

HJS: Which ICU4C version is Chrome on? My understanding is that Safari and Firefox have adopted new ICU4C versions faster than Chrome. That’s my potential explanation. SFC, you mentioned that CLDR was thinking of doing the ISO order with a locale-dependent separator. Do you know why that is their thinking? My thinking is that having that order – having a date that starts with four digits typically unless you do very very far-future years and then has hyphens and two digits and hyphens and two digits, both the ordering and the hyphens are a cue for interpreting it as a big endian date.

SFC: I agree that I also use the separators as a cue for field order, but that doesn’t work with some locales because some locales use hyphens with an ordering that’s not year-month-day. I think they were thinking about this because of a specific user need, the ability to override the field order with a specific locale. There was user feedback from Japanese where some users wanted to change to use a different year-month-day order because they interacted with international contacts but still wanted to use Japanese separators. The proposal was using is8601, they’ve backed that out, maybe considering a locale extension keyword, also there’s a question of whether we should have a calendar named gregory-ymd, gregorian + y/m/d ordering for fields, that’s how I understand what the motivation was for doing this. Having the iso8601 calendar be actually the iso8601 format seems best.

FYT: So, I have some trouble with the iso8601 format, but strictly speaking reading iso8601, it defines the format it can parse, I do not believe it defines the output. For example, your minus sign could have two different minus signs. Your column delimiter as well. Is that true, there’s no one defined canonical version of 8601 format?

RGN: It’s true that ISO8601 does not define a single canonical format.

FYT: So what that means is – if we wanted to define an output for iso8601, I think Temporal did it, then we have to define a more strict version as a canonical way, or provide options to format different way. Otherwise you could have errors in the spec. I’m not suggesting either one of them, simply saying we must choose one of the two, or both. 

RGN: In practice it comes down to RFC 9557, which does nail down aspects that ISO8601 leaves open. Certainly that’s the case for the Temporal proposal parts that interact with ECMA262. 

SFC: I’d like to pose a question to the group. The question is it seems like there’s a desire in the room for the iso8601 calendar in Intl.DateTimeFormat to follow a specific stable output style, as opposed to an ILD format. If that’s the case – and if anyone believes that’s not the case please make a comment – then I still haven’t heard a specific suggestion about how we go about specifying and implementing that. Is it better for us to 

1. Say in the spec that iso8601 should be this vague format, please do it
2. Write down that format more specifically, write tests for it
3. Retract the iso8601 calendar until we figure this out

RGN: For the first: to say that it’s a vague format, that does not provide enough value to justify its inclusion. In terms of how much it can be nailed down, FYT makes a valid point about the decimal separator. In other contexts that is absolutely a locale convention, and might be a little bit strange for it to not remain such when picking a calendar. I’m thinking the American use of the full stop for preceding fractional digits, and the European convention of using a comma. Certainly if you are in a locale that has that preference about what a decimal separator looks like, opting into a new calendar, formatting a date, and seeing a different one could be surprising. That said, this feels to me more than anything else that this is a partial step toward stable formatting, and in stable formatting there is going to be a single choice of decimal separator no matter what other locales apply to. And a weirdness is that it is a partial step toward stable formatting.

FYT: Here's my proposal. I think we're facing two kinds of user. One is a user who comes across something and sees something unexpected and files a bug. The other kind of user is that, I want to format an iso8601 date, I’m trying it, and this doesn’t look like what I want to do. My answer is that we should do nothing about that, and tell them the right solution is to use Temporal. If they convert a Date object not using DateTimeFormat but using Temporal, I think they can produce that already. So instead of fixing DateTimeFormat, there’s another tool in the spec, we shouldn’t fix it but redirect to the real solution. This one, in ECMA-262, we already have a solution, and the solution is Temporal, the toString. So we shouldn’t reinvent the wheel, we should redirect those users to the right place.

LAF: +1

HJS: If then you want to format something that has textual weekday, surely it is legitimate to format a date that you want to be internationally readable, and have that in the ISO year month day format with hyphens and 4-digit year, but still have in whatever language, Monday, Tuesday, etc. It seems like a legitimate thing to do.

FYT: Could you write down one, I have a hard time understanding an example of what it should look like.

HJS: I need to get back to you on that. I was thinking of a weekday as text and then a date, but I don’t know if we have the right (?) for that

FYT: But that by definition is not iso8601 format

HJS: The part where you have the date is in an internationally recognizable form but if you want to express the weekday, for example in English that’s meant to be consumed by an international audience, an international audience that reads English understands Monday, Tuesday, Wednesday, but the ambiguous dates are a concern.

EAO: Here's an example:

> new Intl.DateTimeFormat('th-u-ca-iso8601', { year: 'numeric', month: 'numeric', day: 'numeric', weekday: 'long' }).format()
> "2025-12-04, วันพฤหัสบดี"

EAO: This is an Iso8601 date and a localized weekday. 

SFC: I think that the format described by HJS and EAO is probably the right thing that we would want with this calendar, I think that if this is the path we wanted to follow the next step would be to go to CLDR and see if we can get this adopted at CLDR, and at the same time write it down in the spec and have tests for it. Do we believe that this is the best approach? It is essentially a variant of option 2. And do we believe it’s more correct than just having — we could specify the iso8601 means “make a Temporal ZoneDateTime and return the toString”, which is very easy to specify, and it’s very stable, but I don’t know how user friendly it is. Do we believe that this format that HJS and EAO described, is it more user friendly? From my experience, I like this format and might choose to use it in my day to day – it would be nice to have that be my default calendar, or make it the en-ZZ calendar. Do we have evidence that this is the right thing for users, or are we saying “if this calendar did exist, this is how we think it should behave in order to fill in the gap, we have this gap, we have a void, we’ll fill it with this?” Are we on that side, or are we on the side of this being useful for users.

FYT: I don’t quite understand what that requirement comes from, what EAO – thats’ definitely not the ISO 8601 format date. Strictly speaking that string doesn’t follow Iso8601. We can imagine something like this, but if this is something we need to spend time to work on we should have proof that people do use this kind of thing in real life, the basis standard we decided on years ago is that there should be prior art, and that it is something that’s useful. To me, it says “I want to format with a hyphen”, which is fine but shouldn’t have anything to do with the ISO8601 calendar. People might want a hyphen with RoC calendar. What calendar you use and whether or not use use a hyphen shouldn’t be combined.

EAO: Note that we are here talking about localized and formatted output for human consumption not meant for machine processing. So we’re talking about something like the date part for iso8061 might be for human consumption, and the string as a whole might also include time zones and such that aren’t in iso8601, which is valid. The important thing is that if you are using this calendar for formatting and the parts you’re formatting are numeric in a way that can match an is8601 pattern should match an iso8601 pattern, so that the human who’s reading it can be communicated with.

LAF: +1

HJS: Anecdotally people who communicate in international settings specifically in English have a wish to use iso formatted dates over and over again – I don’t have hard data, but anecdotally it seems as well motivated as the notion [?]. As the hyphen being the feature, that’s not the feature. The hyphen is when at least the locale default separator is either the slash or the period, the hyphen here is very much a signal that this is a big-endian date. It might be more complex with locales where the default is not big-endian and the locale separator is a hyphen, that could be more messy, but there are locales that don’t use the hyphen as teh default separator but use as slash or a dot, slash is all over the place ,the ordering for components with slash are whatever, everything exists in CLDR, it’s pretty clear in CLDR that . implies little-endian. So in the locales where the default is / or ., then it’s an anti-feature to be able to obtain a hyphen without doing the iso order. It’s very much a feature that if you see four digits, hyphen, two digits, hyphen, two digits, you are allowed to assume that this is a big endian date. It’s not like putting hyphen as an option to some other thing.

LAF: +1

RGN: I don’t think it would be valid to defer to Temporal on this. The example EAO provided is to some extent juryrigged. If it were including a time, for  instance, what would be the fractional separator between whole seconds and partial seconds. None of that stems obviously from a choice of calendar. This seems like a partial attempt to achieve stability, but a useful one for reasons that HJS pointed out, and it might be that pragmatically sacrifice the full stability in favor of those human-oriented goals of communicating a big-endian formatting. I don’t know if iso8601 is the perfect choice for this, but it’s certainly a reasonable one.

SFC: Still unclear on next steps. I guess my ideal situation would be that the spec in 2022 didn’t say we needed this calendar supported, so that we could continue having this design discussion. Given that it’s in the spec already, and there may be code assuming the spec, I’m a little worried about stopping support for it in DateTimeFormat. However, the behaviour we already have isn’t consistent between Firefox and Chrome. 

SFC: I think one concrete next step is to have this conversation with the CLDR design group, since there is already one active point for them to take action on this, and we can live with that as the outcome. We could say “if you use this format you’re going to get the iso8601 yyyy-mm-dd fields, with other things localized”. That seems like a path forward that is well-lit, if you will

EAO: Currently in Firefox with the iso8601 calendar you get : as the numeric time part separator, so it is not just the date part that ends up being affected.

SFC: We could go farther say yyyy-mm-dd and colon-separated h:m and m:s, leave it locale defined for weekday, timezone, fractional second separator. 

EAO: I haven’t checked fractional second separator, but shouldn't it be a period?

RGN: no, it supports both . and , 

EAO: One more thing: what we’re talking about here with the calendar selector, this is not at all like StableFormat, because for stable format we’d be talking about strictly following a prescribed iso8601 format and not supporting localized strings or localized variants in any way, because that’s about making sure that there is some format that useful for machine consumption rather than human consumption, and we are focusing on something for human consumption here. They both may use is8601 as a source for building these, but the uses are much different.

SFC: “iso8601 calendar but designed for human consumption” is something that people on this call seem to like. I guess my personal opinion is still that I’m not sure it’s well-motivated, but given that we have to have something there because the spec requires it, this seems like the best thing to put there. And maybe it’s motivated. I don’t think it’s motivated enough for me to drive a proposal, but I think it’s motivated enough to be a reasonable behaviour to fill this void. Assigned to BAN now that we have guidance on next steps.

### Normative: Ignore "islamic-rgsa" calendar in DateTimeFormat #99

https://github.com/tc39/proposal-intl-era-monthcode/pull/99

BAN: So we've had a long-standing problem of the two islamic calendars not being used in practice, islamic and islamic-rgsa. Intl Era Month Code… what we've been doing is having those fall back to something else. What this PR does, based on issue 29, falling back from islamic to a locale-dependent calendar. But islamic-rgsa wasn't discussed. Since we're not aware of anyone using islamic-rgsa, Shane suggested ignoring/dropping it. That's what the PR does.

EAO: So, this is separate from the conversation around Frank's proposal that is adding the table with the calendars that is being supported, right? Or is it related? If so, I'd like for us to resolve that it's part of that context, where we have a standing resolution that's part of that proposal.

SFC: It's the same proposal. But I don't see islamic in this PR. Where is it handled?

BAN: We're looking at step 9 in CreateDateTimeFormat. It already prints a warning. What this PR does is goes a step further and drops islamic-rgsa.

PFC: I think there's a 2-step thing here. We previously discussed in TG2 using implementation-defined fallback values for both of these calendars that we don’t want to support anymore. That is the conclusion that is reflected in the proposal. There was a further conclusion discussed in October, in the TG2 meeting, we actually don’t want the islamic fallback not to be implementation-defined, we want it to be islamic-tbla. Then what with islamic-rgsa? Implementation defined? Is that meaningful, since the implementation very well could just fall back to islamic-rgsa. Two choices:

1. Continue with implementation-defined fallback value
2. Literally ignore it

EAO: So if the proposal is being change to more specifically say what the fallback behaviour should be, then that is great. If on the other hand we keep the current language, the current proposal language is fine, where both emit a warning. In any case, emitting a warning for either of these would be a good idea. I don’t remember what PCO referred to in October, I’m happy about that as a direction. Third, the list of supported calendars should be the ONLY calendars supported, and we should not allow extension from this list. It matches what we do with supporting units, etc in 402, specifying what is valid. We must talk about islamic and islamic-rgsa at the same time so that their behaviour is compatible with each other

HJS: We agred that islamic falls back to islamic-tbla specifically, and at that meeting we did not discuss islamic-rgsa.

FYT: I don’t quite understand this PR. Is this removal observable behaviour? If I create a calendar with this name, what do I get?

BAN: It is as if the option was never there in the first place.

SFC: I realized that the other section of the spec where we handle it with the warning to the console, it’s the same function, you have to scroll down a little more to down there. I was wondering if another conclusion is that this special handling where islamic becomes islamic-tbla and emit the warning and not even mention islamic-rgsa and islamic-rgsa is handled like any other implementation-defined calendar, if we do the special thing for islamic and nothing for islamic-rgsa, and implementations can do whatever they want with it – ignoring it, for example, but also they can do something special with it if they want. But with islamic they must do the thing we specify 

EAO: Preference for fallback for both these should be islamic-tbla with a warning

PCO: What you said should be consistent with earlier discussions and consistent with FYT’s point and everyone else.

HJS: As EAO says, we already have a list of units that are not implementation-extensible. Units are less complex than calendars. If you need an extra calendar, you ended more than an identifier. There is more of a justification for calendars to not be extensible, and if you want to add something more come to this group. As to what to do with islamic-rgsa, it’s useful to issue a warning. What EAO said about doing the same thing as islamic – issue a warning, change it to islamic-tbla, that’s my preference, keeps the identity that’s in all ICU4C browsers. There is not evidence of islami-rgsa being used, and so I’m okay with ignoring it for resolution purposes, but still issuing a warning. We can already reason from islamic-rgsa that it is unsuitable for a temporal calendar, since temporalrequires calendars work for the past and the future with at least some kind of approximation. My understanding is that what islamic-rgsa requested it as something distinct from islamic-umulqura, where there is the observation in S.A. Both the notion that this was requested by Oracle and what’s in the Java doc that this was meant to be a backward-looking calendar, cannot look into the future because those observations haven't been observed. This makes it unsuited as a temporal calendar, which means it’s not controversial to say you can’t implement this with temporal. The sensible thing is to have the same behaviour – issue warning in same spec clause, fall back to islamic-tbla. It cannot be implemented in a forward-looking way, so we cannot give it to browsers. Why would we have a separate thing for this thing that isn’t use where we could have the same thing, retain the identity that all browers have, which is that islamic and islamic-rgsa do the same thing.

BAN: Is there any locale in which these two shouldn’t both fall back to islamic-tbla.

SFC: As I understand “rgsa” means “in the region saudi arabia”, meaning the calendar used as ground truth in saudi arabia. The intent of the subtag is to say it’s used in saudi arabia. Could be extended to rgeg, meaning egypt. Given that there’s no evidence of usage of this, my preference is to just ignore it and say it’s not supported. This keeps the door open for doing additional work in this space – which I don’t anticipate happening in any sort of timeframe. It makes sense to special-case islamic. I don’t think it makes sense to special-case islamic-rgsa, one because we don’t have the evidence that it’s used, two because we might want to keep it undefined so that it can be defined more in the future. That would be my preference. Regarding the other topic – adding additional calendars — that’s the next topic on the agenda. 

FYT: [noting how many different islamic calendars are available]. I don’t know talking about fallback to islamic-tbla. Mostly they’re the same, but the epoch is different in ICU implementation.

https://developer.apple.com/documentation/foundation/calendar/identifier-swift.enum/islamic

HJS: In ICU4C we have established that there is no identifiable user community that uses that calendar. It is just a thing in ICU4C, it doesn’t exist otherwise. Islamic-tbla is the same as thursday-epoch, islamic-civil is friday-epoch. Islamic-tbla and islamic-civil are algoirthmically defined, then we have islamic-umalqura.  [...]

FYT: You keep saying no one uses, but MacOS ui shows 4.

HJS:  It shows it because ICU has it, and if you see that ICU is written by experts perhaps there is a reason for this, so let’s expose it. MacOS previously showed the two [?] that were removed in Chrome because no one uses them. Exposure in UI is because it’s in ICU4C, but no one has demonstrated any use of the calendar that ICU4C calls islamic outside ICU4C. There is no evidence of it being used in a way that matches any identifiable islamic calendar by reference to anywhere but ICU itself.
 
### DateTimeFormat/constructor-options-calendar-islamic-fallback.js should allow other fallback values #4677

https://github.com/tc39/test262/issues/4677

Related: https://github.com/tc39/proposal-intl-era-monthcode/issues/94

FYT: What I say – I think this test is overly testing whatever it inspects. I think there is some interpretation about the spec that says it can only be that, but you have to actually say that in the spec. The tests assume that we have defined a table and the only thing that can be implemented are those in the table. The tests say we have this table defined in the spec, and we have ensured that ONLY those calendars can be implemented. The spec instead says you MUST have those things, but not ONLY those things.

HJS: I reiterate what EAO said earlier: let’s resolve this by making the spec say this is the list, we have precedents for not allowing extensions from the list, we have the precedent of units not being open-ended, and if someone wants to add a calendar let’s discuss it in this group. There are fewer calendars that would be added than there are units that could plausibly be added, so it’s fair to resolve this in the spec by saying “this is the list.”

SFC: I think HJS’s point that a calendar is much more than a numbering system – it’s not just digits, it’s a algorithm, you have to have month codes, so adding a calendar is a lot more than a numbering system. If you have an implementation-defined calendar that creates more interop problems than a numbering system. If browser 1 ships a calendar, the rest of the community may have to say they have to add that calendar too. Instead it’s this body that should have the say over when a calendar gets added. I’d like it more like the units list, I agree, and less like the numbering system list. Because we don’t want a big engine to ship some units and then everyone else has to – it’s okay for numbering systems, since it’s small impact and small data, but for calendars it makes more sense to be more strict.

EAO: If we’re agreed on that, an interesting next step is to make sure that this list is not too full – do we currently include calendars that aren’t used at all? Is islamic-rgsa the only such calendar, or are there others? But +1 to the idea of making this _the_ list rather than an extensible list.

SFC: I don’t agree with the assumption that this decision means we should consider taking elements out of the list. There are two calendars that are questionable – ethiopic-alete-alem for example – but none of the calendars in the list pose a high implementation cost. The list that we have is the list we should stick with. We can add to the list, but I don’t think this discussion here affects the priority of removing elements from this list.

FYT: Two things: I think it’s okay from this POV to make it the exclusive list, but we need to make the change. I don’t agree with you re: open-ended numbering system, and this additional one is not trivial. It is complex enough that the u.s. Patent office was willing to grant me a patent — hebrew numbering system,chinese numbering system, roman numbering system are not as simple as you think. The compatibility is there –  I don’t agree with the statement that numbering systems are easy.

SFC: I didn’t mean ease of implementation, I meant impact of web compatibility. If someone is using a calendar in one browser but not another, temporal will fail to be instantiated, there will be error codes in month codes, cannot be interoperated in the other browser. So when I mean “simpler” I just mean from an interoperability perspective, not an ease of implementation perspective. For numbering systems you can fall back to latn, but if chrome supports furlongs and mozilla doesn’t there’s no clear fallback for mozilla. If Chrome supports roman numerals and Mozilla doesn’t, Mozilla can just fall back to latn.

SFC: Sounds like the room agrees that the calendars should be a closed set. This is a change to the spec, since it clearly states that you can return implementation-defined values, and it says this as of two weeks ago (see thread 94).  PCO, what do you think about this?

PCO: I guess I don’t care that much. My main goal here is to not make TG2 the authority on calendrical calculations. The situation I want to avoid is that before a new calendar can be added it has to have someone in TG2 who is an expert on the algorithms of that calendar. It’s certainly simpler to make it a closed set.

SFC: I think the process for adding a new calendar is going to be – you have to have someone come to TG2, we add a row to the table, and this table specifies the algorithm of the calendar in prose, and in addition to that they need to add the era codes to this table, the month codes to this table, and the ISO year conversion to this table. That’s the process of adding a new calendar.

PCO: That’s as reasonable as we can make it. 

RGN: That is straightforward, but it doesn’t speak to whether a calendar should be considered non-conforming if it supports a calendar not in that table.

HJS: Presumably it is as non-conforming as an implementation that supports a unit that isn’t on the list of sanctioned units.

RGN: Only the case if we’re explicit about it – units is closed set, number systems are open set. 

RGN: The list of sanctioned units is unusable in 402. I can think of two: timezones and sanctioned units. Anything else an implementation is allowed to go beyond the spec and still be conforming. 

SFC: Do we agree that we want to make AvailableCalendars (the list of calendars supported by Temporal) be a closed list more like the list of available units as opposed to the list of available numbering systems?

HJS: I support making it a closed list

EAO: +1

### Revisit Normative: Ignore "islamic-rgsa" calendar in DateTimeFormat #99

https://github.com/tc39/proposal-intl-era-monthcode/pull/99

SFC: Given that we want the calendars to be a closed set, then what we do with islamic-rgsa is much less risky, since we don’t have to worry about engines implementing it in a weird way we haven’t considered. So have islamic fall back to tbla as a warning, and for islamic-rgsa we just don’t mention it in the spec – which means it has to be dropped. I should clarify that the behaviour I’m assuming is what we discussed in October, which is that a calendar that’s not a calendar specified in temporal it’s an error, but if it’s a calendar that’s not supported in DateTimeFormat it’s a fallback, normally to the locale default calendar, but in the case of islamic, a specific fallback calendar.

HJS: So either falling back to tbla or treating it as unknown is fine. If that’s easier to get through the committee, that’s good. That doesn’t prevent anyone from issuing a warning, even if the spec doesn’t call for a warning.

EAO:  So I was presuming that we were erroring on unsupported calendar identifiers, like we error on unsupported options. Making it an error if it’s not currently an error is not webcompat. But is it webcompat to issue a warning and fallback to some default locale calendar?

SFC: The web reality is already that if you give a calendar that’s not supported, you fall back to the locale default. This doesn’t make anything lese compatible. If you ask for u-ca-tibetan, it’ll just fall back to locale default

EAO: New behaviour I’m asking for here is that if you ask for u-ca-tibetan that we do the fallback and also emit a warning.

SFC: In Intl.DateTimeFormat?

EAO: Yes. I’m not saying it currently happens, but I’m saying it should happen.

RGN: You’re looking for the specification to include a step? Is there prior art for that?

EAO: Yes. The language around islamic fallback.

HJS: We had some prior art for deciding to do the wording for islamic itself, but I forget what it was. 

PFC: Yes, I forgot which it was

FYT: It’s in 262. Annex B.3.2. Block level function declaration, paragraph second from the last. 

RGN: That occurs at parsetime. This should occur at instantiation time of a DTF instance?

FYT: I just do not know how this go implemented. 

RGN: Also I note that the ECMA-262 text, because it’s parse-time perhaps, is not an algorithm step. “If there’s a mechanism for producing diagnostic warning messages, a warning should be produced.” We could do something similar, but it’s worth noting that it would be the first such instance.

EAO: Observe that the proposal already has that language in it.

FYT: Maybe we should remove it. I don’t know how to implement it, to be honest. 

SFC: I’m neutral on requirement to print the warning message. I’m find that we do. I’m sure we should it for islamic, not sure other unsupported calendars. I don’t think we should tread into – it might be a slippery stuff for unsupported calendars, like, should we do it with unsupported regions, numbering systems… ? Why are calendars more important? The islamic calendar specifically has a reason for it, but the generic case of an unsupported calendar doesn’t rise to that level.

RGN: I agree with those comments and also have some concerns about the text as it appears, because if you’re creating a formatter in a loop, that encourages the implementation of creating warnings of the same cardinality, much less of a concern with 262 since it happens at parse-time

HJS: I think we should keep the wording for islamic and if it’s a problem in a loop, we don’t warn about the same thing more than once per document if that is a problem for a particular kind of warning.

SFC: As a conclusion, I think we should drop islamic-rgsa from spec text (let it be handled like any other unsupported calendar), and keep the warning text for islamic, but possibly revise it based on feedback from Frank et al.

BAN: +1

HJS: LGTM

EAO: +1
