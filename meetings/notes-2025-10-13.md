# 2025-10-09 ECMA-402 Meeting

## Logistics

### Attendees

- Shane Carr - Google i18n (SFC), Co-Moderator
- Ben Allen - Igalia (BAN)
- Henri Sivonen - Mozilla (HJS)
- Yusuke Suzuki - Apple (YSZ)
- Frank Yung-Fong Tang - Google i18n, V8 (FYT)
- Richard Gibson - OpenJS Foundation (RGN)

### Standing items

- [Discussion Board](https://github.com/tc39/ecma402/projects/2)
- [Status Wiki](https://github.com/tc39/ecma402/wiki/Proposal-and-PR-Progress-Tracking) -- please update!
- [Abbreviations](https://github.com/tc39/notes/blob/master/delegates.txt)
- [MDN Tracking](https://github.com/tc39/ecma402-mdn)
- [Meeting Calendar](https://calendar.google.com/calendar/embed?src=unicode.org_nubvqveeeol570uuu7kri513vc%40group.calendar.google.com)
- [Matrix](https://matrix.to/#/#tc39-ecma402:matrix.org)

## Status Updates

### Updates from the Editors

RGN: No updates.

BAN: No updates.

### Updates from the MessageFormat Working Group

Skipped this month.

### Updates from Implementers

https://github.com/tc39/ecma402/wiki/Proposal-and-PR-Progress-Tracking

YSZ: No particular implementation updates, but need test262 links for some of the features

FYT: Similar feedback, some of the links are weird

BAN: I’ll audit those this afternoon

FYT: First update: PR about locale variants – don’t have a set day to launch it, but I’m working on it. Second, intl.localeinfo used to have this getter thing, but we changed it to functions a little while ago, safari removed the getter and added the get function, firefox hasn’t updated it yet, getter is deprecated, just got approval from v8, they were afraid it breaks compatibility, I don’t think it’s tracking here, it’s a change inside the localeinfo API, I just wanted to make a note of that for everyone. Note that PR 960 has tests, we just haven’t added the link to the wiki

HJS: No updates from Mozilla

### Updates from the W3C i18n Group

SFC: I was on an email thread about integrating github updates – they want us to add a w3c tag so that they can scrape our update, or a w3c: something tag, I think that’s fine and should be done on an as-needed basis. They wondered about scraping all tc39 org repos, that’s a little out of scope, but as far as ecma402 proposals, adding a tag to allow those repos to be scraped by their tools would be fine.

## Proposals and Discussion Topics

https://github.com/tc39/ecma402/projects/2

### Intl Locale Info for Stage 4

https://github.com/tc39/ecma402/pull/942

FYT: Hopefully we can resolve these issues today and go to TC39 – there’s one normative PR we have to get their consensus on, too. Once they agree on that, we can get an agreement to go to stage 4. 

FYT: Basically, only two issues remain. Let’s start with the easier one first, the editorial one.

### Editorial: Add note about inferring text direction from locale #103

https://github.com/tc39/proposal-intl-locale-info/pull/103

FYT: The issue is a suggestion to add an editorial note that you can use information from LocaleDirection as a fallback mechanism while there is no metadata associated with the text to provide direction information. 

SFC: I think it’s a positive change, putting this in the spec is good, we can add it to MDN as well. I’m not interested in delaying this proposal further, but it raises questions about whether the getter should be called defaultDirection rather than direction, but this proposal has changed way too much in stage 3 and I’m more inclined to just add the note. I’m very much in support of this.

HJS: I think it makes sense to have an informative note, but this last sentence should be removed – it’s directing users to an API that doesn’t really exist in the platform

SFC: That’s a good point – string-meta is a draft proposal. 

FYT: HJS proposes we remove the last sentence, is there support for that? I think it’s a good point, but I want to hear opinions from others.

SFC: Is this a normative specification or just a note?

HJS: We shouldn’t treat a note as a standard. Also, there has been previous disagreement on the implementability of the note. But the main thing is that since it’s not implemented we should not tell users to use an API that’s not there.

FYT: I propose that I change the PR to remove the last sentence, close the issue and say we’ll re-add the removed part when implemented by engines.

SFC: I wanted to propose that we could – I think this document has a lot of details and information about this subject, so it seems useful to reference it even if we don’t – maybe a sentence that says “for more information on this subject, you can read this document.”

FYT: SFC suggests that instead of saying it’s an API, just say “for issues related to this, read this one.” How do you feel about that, HJS?

HJS: Last I was in a w3c meeting where this document came up, I’m not sure if the controversial parts have been removed, or if they’re still there. The controversy was over the JS String object should have more fields.

FYT: I would object to that proposal if I have a chance – it’ll blow up the whole memory

RGN: What would be the intent of linking to this document?

SFC: I guess linking to this section, the intent would be to give – this document has much more information about how you should deal with text directionality when writing an application, it has a lot of information about the different approaches that one can take and the advantages/disadvantages of these approaches, which is more information that we can fit in a note in this specification. If we’re okay with the user doing their own research they’ll land on this page anyway, but it seems useful to me to guide them toward this in their research. I would link to the overall section rather than what we have. 

RGN: I notice normative language in this – “must” – is this aspirational? Is it descriptive? I’m not clear on the purpose of this section either, but if we’re going to link to it we have to clarify the nature of the link. 

FYT: How about this, SFC – this is an editorial PR, HJS has a concern, I agree with that: this w3c note itself is not a mature thing. Since it’s editorial, if we really want to do something we could do it post-stage-4, and as HJS suggests take the most conservative approach and simply remove the last sentence.

SFC: RGN’s point that this specification looks like it’s using normative language even though it’s just a group note – and therefore not approved by anyone – is sound. I think it’s useful for informational purposes, but linking to it from our specification is maybe giving it more weight than it deserves. If this were linking to a wikipedia article or something like that it would send the signal that it’s purely informational, but linking to this document doesn’t look like that.

RGN: Perhaps we could link to it and specifically disavowing the editorial strength of that link. Say “treat this as a source of documented reasoning about the topic.” 

HJS: A quick skim of the document – looks to me like the way of associating more fields with a js string is now accomplished with webIDL dictionary, but still it’s a spec that’s not implemented in browsers, so if we point to this it has stuff like webIDL that you won’t find an implementation of in browsers. The text of the proposed editorial note is sufficient without the last sentence.

FYT: We could just remove everything after the comma – the “but rather” clause. 

SFC: That seems fine to me

FYT: Can we agree on that? RGN, HJS?

HJS: It works to me to end with a period where the comma is and delete the “but rather” clause

RGN: Yes, that’s fine

### Normative: Add more explicit algorithms for lookups #92

https://github.com/tc39/proposal-intl-locale-info/pull/92

FYT: What’s happened here is that previously the language I used here was very high-level – “yeah, just return the thing” – and anba suggested using a more detailed algorithm. Made some changes with the direction part, since it was already addressed in earlier PRs. It’s a normative PR, it makes something high-level more explicit in the language. I hope we can review that and agree on it. 

HJS: I’m in favor of merging this.

SFC: I haven’t read this in detail. If FYT thinks this is a positive change and HJS thinks it’s a positive change, then I’m probably okay with it. I’ll give it a more thorough reading in advance of the next TG1 and if there are issues I’ll raise them, but I don’t anticipate there being any.

FYT: Yes, it makes the algorithm more specific – but basically, it’s just “do what ICU does”

SFC: Yes, I am in favor of that, I’ve done something similar in the intl era monthcode proposal, where I’ve taken text and replaced it with steps.  I’m generally in favor of that kind of thing.

YSZ: The newly described thing reflects how current ICU is working? If so, I’m pretty much fine with it. 

FYT: Seems like we have consensus that this is okay, people should review it and give explicit LGTM. No objections? 

YSZ: No objection

FYT: I’ll close this issue. Next thing, since there’s only two issues about this stage 3 proposal at this time, the next thing I would like to ask for your consensus on, once we’ve merged these together we’ll move intl localeinfo API to stage 4. I’ll have to update the PR that’s there, since I need to re-synchronize it. 

### Intl Locale Info for Stage 4

https://github.com/tc39/ecma402/pull/942

FYT: Do we approve stage 4 for this proposal?

YSZ: Seems fine. I approve moving this to Stage 4. It is implemented in many engines. I expect that this meets Stage 4 criteria.

FYT: Chrome has it, Edge has it, Safari has it, we have two implemented.

YSZ: Counting JSC as an engine implementing this, that’s fine.

SFC: I have a question: the specification has changed a lot since we’ve approved it for stage 3, biggest was changing the getters to be functions, I think we’ve removed some fields and tweaked some things around the edges, how up to date are the tests, and do Chrome and Safari pass the test262 tests?

FYT: Tests are updated, both engines pass the test.

YSZ: Yes, implementation updated, test262 is updated, yeah.

FYT: I’ve added new ones, haven’t removed old ones because chromium concerned about compatibility, got approval from them yesterday, 143 will remove that, they have concerns about adding a kill switch if anything goes wrong.

SFC: Has safari removed the getter?

FYT: Yes, a long time ago.

YSZ: Confirming that we’ve removed it.

SFC: And Chrome 143 will be shipping in time for the next tg1 meeting.

FYT: Not necessarily – it’s a baking period, but it doesn’t matter, it’s on the oven already. We are going to remove that, so it doesn’t really matter in a sense. And that is not in the spec anyway.

SFC: With all that info, I’m glad to finally graduate this. 

FYT: I’ve already added a 30 minute agenda item for this. I’ll close the editorial one after whatever HJS suggests, then we’ll only have one remaining issue, the fallback thing, I’ll bring that to tg1 and also stage 4 proposal, and so if they agree to the first one I’ll ask for stage 4. 

### Normative: Delete superfluous era aliases to align with CLDR #72

https://github.com/tc39/proposal-intl-era-monthcode/pull/72

SFC: There’s some things that got out of sync between CLDR and the tg2 version of this proposal. The version that landed in CLDR 48, which is in beta and will be finalizing in a couple of weeks, strips out all of the era names except for the names that are just a single default era name, the primary era name for each calendar, and it keeps a very small number of aliases.

SFC: Currently in the specification for buddhist we have just the one era name, for coptic just one name, currently we have mundi and incar aliases, the proposal is to remove them so that we have one primary name for each era. The only calendars that have aliases are gregory (bc/ad, bce/ce), hebrew no alias, hindi, we just call it shaka, islamic-civil, single name, no alias, no alias for japanese, and then the last one we’re removing is the other aliases for minguo / other aliases on the ROC calendar. Removes all aliases aside from ce/ad and bc/bce aliases. Already updated in CLDR, out of sync, there’s not a single place to make these decisions, and tg2 is the body that I think is basically been taking ownership of which aliases we want to see. So I’m asking if this group approves of this change to remove these aliases from other calendars. 

SFC: The natural first question do we risk breaking the web? No, because we’re not shipping these, they’re already rejected in ICU4X, I don’t think anyone is currently taking them. The other question is why are these here? Is there a use case behind them? I think the answer is no – someone in our sphere invented these codes because we needed a code, then we did research and discovered that the new codes are better, but we didn’t delete the codes that we had invented before we did the research.

HJS: Let’s do this – it looks good. Thanks!

SFC: Any other comments? I do need to update the PR to delete this last line, so basically what I’m asking is approval to land this PR and delete the last line that I realized while presenting today I hadn’t deleted.

YSZ: Looks perfectly fine to me – thank you for working on this thing.

SFC: If no more feedback, then that’s sufficient to say we have TG2 approval 

### Normative: Add wording for buddhist calendar complexities for pre-1941 dates #76

https://github.com/tc39/proposal-intl-era-monthcode/pull/76

BAN: The Thai Buddhist calendar changed in 1941. Most other calendars that we use proleptically have been proleptic since before any living person was born. An exception is the Thai Buddhist calendar. Before 1941 they had used a new years day of April 1 instead of January 1. Do we want to change the calendar to accurately reflect birthdays before 1941, or extend proleptically the calendar?

HJS: I checked what the JDK and .NET do, and they both do the proleptic era shift, no April 1 new year. .NET doesn't have any additional eras, because the calendar does not support dates earlier than the Common Era; JDK has a Before Buddhist Era era. But they both do a proleptic era shift, which seems to be the software industry convention. We don’t seem to have users asking for April 1 new year prior to 1941.

BAN: Thank you for doing the research on .NET behaviour, I had checked the JDK but not .NET

SFC: My feeling is that there’s definitely questions about whether we should try to make calendars match ground truth or whether we should make calendars be proleptic and let users piece them together. With the gregorian/julian situation we have an okay solution – we don’t have julian in ECMA, maybe we should – but in ICU4X we export both gregorian and julian and allow users to select the change date by gluing together the two calendars. For Buddhist there’s no controversy about the change, so it’s not like a proleptic buddhist calendar before 1941 is useful for making a userland-level switchover date. Basically I think the right thing to do would be to have it be – to have the new year be april 1st before 1941, that’s the right thing to do if we were starting from scratch. There’s two things to raise – this was in response to a bug from a user, it wasn’t us doing this research. 

SFC: ICU issue 23161 is where this issue first came in. Bug report that came in to ICU4C, “thai calendar has wrong month numbers for years <= 1940”. I don’t know where this user came from, a different user also noted that ICU4X doesn’t work well for genealogy apps. I don’t know who this user is, but they definitely are a 3rd-party user. I’m showing this to show that HJS’s statement that it’s intl era monthcode people pushing this isn’t true.

RGN: I think we can take that result at face value – here’s a program that takes a gregorian date and converts it to a thai buddhist date in the thailand locale.

HJS: I recognize the name, this is the implementer of GNU iconv. We shouldn’t view this as a user from Thailand asking for stuff, but instead as an implementer poking at edge cases. 

SFC: I’ll note that another comment is – I had also asked the CLDR committee about this, and they said that we should do research, they’re currently doing research with Thai LPNs, which may feed back into this is, about what the expectations are for users in Thailand. 

SFC: My conclusion here is that the reason – if we did this for buddhist, there’s only one reason, and that reason is that we’re trying to seek compatibility with other systems that have already made this decision, but we’re not endorsing the idea of projecting proleptically pre-1941. We’re not doing it because we think it’s okay, but we’re doing it to match software precedent (JDK, .NET, ICU). If we agree that that’s the motivation, that’s fine. I just don’t want this to be cited as evidence that calendars before 1941 don’t matter, we don’t care about the accuracy before 1941, because we do care about the accuracy before 1941. I’d prefer that the language reference that we’re doing it to be compatible with other software systems. 

BAN: +1

SFC: BAN tweak the language, and we can approve it – one thing we can do now is to say we approve that we want the proleptic behaviour, and then we can work on the language of the PR before we land it. HJS, or anyone else want to voice support for this approach, i.e. continue having the buddhist calendar be proleptic pre-1941

FYT: No strong opinion. I think it’s okay.

SFC: YSZ?

YSZ: I think it looks just fine, I don’t have a very strong opinion about this topic. 

SFC: We can mark that as approval, then.

### Editorial: Add calendar authority for Japanese Imperial era names #79

https://github.com/tc39/proposal-intl-era-monthcode/pull/79

SFC: This is editing the same table that we’re looking at, but with Japanese. 

BAN: The Japan government is the authority for the name in Japanese. But who is the authority for the transliteration? It seems CLDR is the authority.

SFC: Maybe we could just say that the era names are defined by the government of Japan, but the ASCII versions are as defined by CLDR. Maybe just say “era codes”... maybe we could say that all era codes are as defined by CLDR, which derives them from the government of Japan.

RGN: If we wanted to be ECMA-402 style, it would be a recommendation, rather than a normative reference.

SFC: I believe that we already list the era codes in this document. 

RGN: What’s setting this apart? We don’t even require consistency of the interpretation of locale identifiers, other than their structure. 

SFC: We’re not wading into trying to change – note that this section doesn’t define the era codes, we don’t even – this is the language that talks about the algorithm, rather than the era code. The government of Japan defines the algorithm and the era ranges, if you will. “The era ranges are defined by the government of Japan”

RGN: Yeah, I like that. As a heads-up, the next big thing I’ll be looking at is the relationship between ECMA-402 and CLDR, particularly what behaviour is allowed vs disallowed with a conforming implementation. We can do it piecemeal, but I would like proposal authors think in terms of “is a conforming implementation allowed to have a differing opinion on any aspect of the proposal.” In this case it’s clear that a conforming implementation can’t have a differing opinion of what codes exist, and so citing the authority of this makes sense – may not be allowed to have an opinion on the time range of any given code, but it should be clear from reading the spec whether or not it’s allowed to do so. 

HJS: As a practical matter I’ve filed a followup to this issue – being explicit about the day/month of the start of the Meiji era that this spec expects, since there’s been a widely propagated bad start from CLDR. In that sense I’m not a fan of trying to keep things super abstract for these things that are grounded in some actual thing. 

SFC: I think HJS’s point is that citing CLDR for calendar algorithms is not good, since CLDR has bugs and CLDR data will change when we discover and report this bug. That’s why we should cite the actual authority. 

RGN: It’s irrelevant, though. Whether they’re cited or not, if this spec says that conformance requires certain eras with certain changes, then it’s purely informational that it’s derived from a specific authority.

SFC: The spec doesn’t define where the codes start and end, this language just says that the eras correspond to those defined by the government of Japan, and it’s up to the implementation to make sure that they do.

RGN: Which means there can be no conformance test for that.

SFC: The conformance test would be to scrape the government of Japan site and verify it. We might want to do something similar with the Chinese calendar. 

HJS: As a practical matter we should have tests for when the Japanese eras begin, especially given the history of CLDR bugs for this matter. Whatever spec lawyering allows those tests to exist should exist. 

SFC: My suggestion: BAN tweaks the language again based on the feedback today

BAN: To confirm: We want to say that the era ranges are as defined by the Japanese government, but leave names out of it. Correct?

SFC: +1

HJS: +1

### Editorial: Be explicit about the Gregorian to Meiji switchover month and day in the Japanese calendar #86

https://github.com/tc39/proposal-intl-era-monthcode/issues/86

HJS: So, CLDR for the longest time had an incorrect date for the start of the Meiji era – fortunately within the same gregorian year, so the problem doesn’t cascade to year numbers, it just affects certain months. Since the spec says “starting in ISO year”, we change it to “start on ISO date 1868-10-23”. That would communicate that this is the expectation of this spec, and if you have software that does otherwise, that’s the bug. 

SFC: My question is that when the Meiji period started, did they immediately start doing proleptic gregorian?

HJS: The adoption of this calendar was on January 1st / Meiji 6, so this is an oddity that needs – whatever we want the behavior to be, we should be explicit about it. What happens before January 1st Meiji 6? Is it Meiji 5, or gregorian year? The spec seems to say it’s proleptic within Meiji to the Meiji start date – 1868 October 23rd – and fall back to gregorian before that. The bug in CLDR is that it interpreted a lunar date as a gregorian date, and that’s how CLDR got an earlier Meiji start date still within the same year. That’s the bug. It really helps to see what the expectations of this spec are in a way that’s not vague or roundabout. I think it would be a valid design to do Meiji era back to 1 January Meiji 6, and fall back before that, but my understanding is that that would be a normative change, and I’m just asking for an editorial change. It’s just weird for the years where the Meiji era had started but this calendar wasn’t in use yet. This is just an editorial statement of what the Meiji start date is, since the wrong one has propagated so widely.

SFC: I’d be okay with either of those outcomes. I think listing the date here is harmless, especially if it aligns with the authority. If this is actually the date that the emperor took the throne, then it’s a date that’s harmless to cite — and would be just an editorial change. And starting at Meiji 6 is also a reasonable approach to take, that would be a change that would be a little more widespread, would also have to tweak the ICU4X algorithm to do it too, so saying editorially that “this is the date where we start” minimizes external impact. I agree that the change proposed here is the smaller one, and we should err on the side of small changes.

HJS: Yes, what I’m asking for here is purely editorial, not a normative change, but it would help readers, since there’s that incorrect date out there in old CLDR.

SFC: I completely agree. Thank you for doing the research on this.

### Which Hijri calendars should Temporal support? #29

https://github.com/tc39/proposal-intl-era-monthcode/issues/29

SFC: Here’s the conclusion that I had previously put forth with tweaks, removing ILD and making it resolve to "islamic-tbla". 

```
// Must return "islamic-tbla". May print a warning to the console.
new Intl.DateTimeFormat("en-US-u-ca-islamic").resolvedOptions().calendar;

// Must return "islamic-tbla". May print a warning to the console.
new Intl.DateTimeFormat("ar-SA-u-ca-islamic").resolvedOptions().calendar;

// Mandatory exception ("islamic" not supported in Temporal):
Temporal.PlainDate.from("2025-06-09").withCalendar("islamic");

// Mandatory success ("islamic-umalqura" must be supported in Temporal):
Temporal.PlainDate.from("2025-06-09").withCalendar("islamic-umalqura");

// Must return "islamic-umalqura":
Temporal.PlainDate.from("2025-06-09").withCalendar("islamic-umalqura").calendarId;

// Mandatory success (all calendars returned by Intl must be supported by Temporal):
let calendar = new Intl.DateTimeFormat(anyLocale).resolvedOptions().calendar;
Temporal.PlainDate.from("2025-06-09").withCalendar(calendar);
```

SFC: I’m convinced here by the point that HJS made that since this is fallback behavior that we don’t want people to reach, spec-defined solution rather than ILD solution is better. Is what I’ve written something that we agree on?

HJS: LGTM! 

SFC: Then we should follow up with any PRs needed to implement this, some may be in intl era monthcode, some may be in 402 directly, so making those normative PRs and then approve them at the November meeting so that we can get them approved in Tokyo

RGN: Is there missing specificity – the initial ones assert that if it’s islamic then the output is islamic-tbla, the one that follows it says mandatory exception, the two that follow it don’t have any assertion about the resulting resolved options calendar. Is it necessarily preserving islamic-umalqura? I guess just narrowing in on that one.

SFC: [added // Must return “islamic-umalqura”] 

RGN: Just wanted to verify that this is asserting preservation of that.

SFC: Yes, just checking that that’s what the polyfill does, yes, that’s the correct line of code.

### Stage 2.7 review feedback: Be more specific about safe date ranges

https://github.com/tc39/proposal-intl-era-monthcode/issues/64

SFC: As a discussion I had with HJS in ICU TC. 

SFC: “Safe”, here, means a date that corresponds to the ground truth for whatever calendar there is. We’ve already made an exception for the Thai buddhist calendar, not because it’s the right thing to do but because it matches what other software does. For all other calendars we have more control over what we set that date to be. If we choose a date that’s before Meiji 6, then that would require us going back and doing stuff we don’t want to do with the Japanese lunar calendar, so I don’t think we should – picking a date before 1884 would require us doing extra work that we don’t want to sign up for. And likewise the Thai solar calendar was adopted in 1888. The way I see this, we start from the perspective of wanting to match ground truth as much as possible, and qualify that by saying that there’s real implementation concerns, real disagreements on how these calendars behave, and so we make a resolution for how far back we want to try to match ground truth. We _can_ match ground truth beyond that, but this is how far back we guarantee. The rule I would like to pick, because it’s simple and clean, is we look at the oldest person currently alive and take their birthday, that’s the limit, and in order to make it clean we round it to the nearest decade – which ends up being 1900. That’s how I’d like to arrive at 1900. It’s not the only rule. Another rule could be that we go back multiple generations, or we just pick 150 years, 125 years, which conveniently also puts us at 1900. We could also just pick it because a lot of old computers use January 1 1900 is their epoch. I wanted to do the oldest person alive thing because it’s based in an actual realistic principle. We could also use a shorter range – it’s the founding of the united nations, we could pick wwII as the cutoff date, we could do many things. We could pick some arbitrary event. 

HJS: I think it’s relevant to surface some constraints and implications before we get too far into the discussion. The first constraint is that for islamic-umalqura, we don’t have an algorithm, [someone] gives it to the unicode consortium, so we have a date range and we can’t, we are unable, to do the thing that the calendar is outside that range, because there is a calendar steward and they say what it is, and then we have a limited date range. In practice that date range is from nov 12 1882 to nov 25 2147, so that’s the constraint. An implication is that if we discuss this in the abstract, or from the oldest person alive, then we would end up for a rule where the start date could be earlier than 1912, and 1912 is where the present chinese calendar algorithm starts. But, it happens to be so that the oldest person alive within the cultural sphere of use of the chinese calendar is born sometime later than 1912, so if we did global oldest person alive thing, we would have complications that are not practically applicable to oldest person alive who could reasonably be using the chinese calendar for birthdays, or if we want to have use cases, saying someone’s birthday according to the chinese calendar. And then the indian national calendar is the latest to be adopted, but it’s gregorian-compatible, works fine proleptically, we don’t need to be that bothered by that adoption date constraining it. But we’ve already discussed the thai buddhist calendar in this meeting, and we probably don’t want to revisit that. This is to say that I would prefer us not to try to formulate a global abstract principle and instead look at calendars based on use cases and constraints. 

RGN: Well said, HJS. I agree. I think that any type of global principle is likely to paint us into an awkward position, and it’s just not necessary. We don’t need to get cute on what should work and what can’t – ever calendar has its own constraints, and accommodating them requires giving up on the principle of universal correctness to varying degrees. We just need to acknowledge that reality. 

SFC: One place we have this specification which we agreed to do is specifying a range in which MonthDay reference years need to remain valid, since MonthDay reference years map into ISO, and we want to be able to have a universal solution so that reference years for MonthDays can be interop between implementations. We made a choice to have a universal range for those, which is 1900, we could go revisit making calendar-specific exceptions there if we wanted to, I think that having a universal range makes things a lot simpler. The only implication is the idea that, what do we do with a date in the Chinese calendar before 1912. There is an answer here: the answer is not using the modern algorithm that was adopted in the 1940s. The dates are different. But there is an actual answer to those. By _not_ specifying a principle, we get into the situation where engines have to make arbitrary decisions, which is what we want to avoid. We’ve been having a debate amongst the ICU TCs about what to do with Chinese calendar dates, and there are differing opinions on how many years we should support, and that’s frustrating. Saying “these are the years we should be caring about” is a useful thing. I don’t agree with the idea that this is a calendar-based decision. Instead we have a global principle and then exceptions. One reason to make an exception is with the Thai buddhist calendar – there’s too much software we don’t want to break. Another reason to make a change is that it would require us to implement a whole new algorithm, or something like that. Another would be that it would cause engines to have to ship a lot more data, for some definition of “a lot more.” Those are reasons we wouldn’t want to match ground truth. But absent those reasons, we should. That’s where I say that calendar-specific constraints should fit in. Absent those, we should default to matching ground truth.

RGN: When you talk about making a change, what circumstances are you imagining? We have a finite set of calendars right now, I accept your premise that it is necessary to define a range for each of these calendars right now, and then what changes are you anticipating after that has been accomplished?

SFC: In practice?

RGN: we dont want implementation variance. We could say “Chinese calendar, 1912 to future, gregorian calendar any date valid, buddhist calendar we just defined, Japanese is good from 1900 on or whatever.” Define a range for each calendar, implementations are required to conform in that range for that calendar, then what do we need? Why do we need a global principle? I accept the premise that it’s necessary. The principle used, or absence of principle used, is irrelevant once that range is established.

SFC: We’re in a situation where we used the live person example to determine that Meiji was the first era to accept for the Japanese calendar. Now we need to work with the Chinese calendar. I’m coming out of a contentious meeting where people told me that the live person principle is one I invented, which is not true – we used it in this committee for the Meiji start date. I want to do this so I don’t want to be accused of coming up with it.

RGN: If we start with that principle but we can’t actually go back before 1912, then the principle is irrelevant.

SFC: If that’s true, then that’s an exception to the principle.

RGN: Then what is the purpose of the principle? If we can’t go back before 1912, then it’s the beginning. If we can, then we ought to, regardless of that principle, because we have the overriding principle that we want accuracy. We’re not going to establish a cutoff for the Gregorian calendar for 1900 – proleptic Gregorian is so common that there are no hard bounds on it.

SFC: One of the implications with Chinese is that we can push it back farther – to 1900, to 1800, to the 1600s. We have data and can push it back very far. We don’t have to stop at 1900, at 1912, at any arbitrary date. We can push it back arbitrarily far. But at some point pushing it back further and further makes browsers 0.1% bigger to download for no perceived user benefit. That’s where having a sunrise, or a range of dates that we feel are important, can be a good principle for us. The issue with the Chinese calendar is that – well, it’s already been stated.

HJS: For the application of the oldest living person rule to the Japanese calendar, I wasn’t here when that was done, so I’m not contesting that that rule was applied, but it is relevant to remark that there is a more obvious way to arrive at the same conclusion, which would be that the calendar scheme that is currently in use was taken into use on January 1 6 Meiji, which makes Meiji the first era that has non-proleptic years in the calendar, and then we can proleptically fill back that era and not use past era. You can reach the same conclusion without invoking an oldest person rule by looking at when the calendar was put in use. I was also in the previous meeting today that SFC referred to, and not getting agreement from this meeting and then seeing if this meeting can resolve the issue of that other meeting and if we’re seeking this meeting as being a tiebreaker to that meeting, it would be fair to have the other viewpoints from that meeting represented here, and also to give – maybe paste the points that have been made here.

HJS: So there are these different cutoff dates that we know about. 1912 is the start date for the current algorithm for the Chinese calendar. 1900 is a date for what you can get as a PDF from Purple Mountain Observatory. If you order a printed book from PMO, you could get a publication that goes earlier than 1900. Then there is a person on github who have said that they’ve checked multiple sources data back to 1645. What I haven’t checked but was said in the meeting is that 1645 would be 1 kb, and if we trust the research of this person, it would be technically simple to go back to 1645. Going farther back than that is possible to research, but someone would have to do that research. If we go back to 1900, then it’s 11 years of non-algorithmic data, which is an oddly short period of doing something different from the current algorithm, but then there’s the issue of, well, if that’s an oddly short time to go back, then what amount of time isn’t oddly short? The only decision is to not use old data at all and start at 1912. That’s pretty much the set of issues. 

SFC: I think that’s an accurate summary. I also – the way I want us to look at this problem in this meeting is through the lens of what’s best for users on the Web platform, and I think that’s a different lens than the one we used in the meeting earlier this morning. I don’t intend to use one body as a tiebreaker for another body. It’s both right and wrong to accuse me of driving consensus that one body can influence another. I can make ICU4X that makes TG2 be constrained, and I can make TG2 do something that makes ICU4X be constrained, and I try to work in good faith, though all of us here wear multiple hats and it’s difficult to avoid that situation. I don’t like the wording that I’m here to break a tie. We have a different perspective here – what’s best for users of the Web platform – that’s different from ICU4X’s perspective. I think the question “how many years do we have to include for it to not be oddly short” is a good wording, and a good frame for discussion. That’s why I like having a principle, since “oddly short” is also arbitrary. My strongest held position is that there’s nothing special about 1912. It happens to be the date that PMO started using an updated method for measuring moon sets and such that’s more accurate, they changed their offset to be GMT+9 rather than GMT+ some fraction, and I think there was a revolution in 1912 in China, a political event, but other than that there’s nothing special about 1912 in terms of the implementability of some calendars. [missed some]. The PMO algorithm is not just a proleptic algorithm that one can calculate. If it were, then my position would be different. But it’s no harder for us to implement starting in 1900 vs 1912 – same level of difficulty. Same with dates in the 1800s. When you go back to the 1600s, then the question of the kilobyte of data becomes more meaningful.

RGN: For clarification, we’re literally talking about one thousand bytes of data? To go back to 1645 is fewer characters than exist in the document we’re looking at right now?

SFC: Every year we have for ground truth data is 3 bytes per year. 

RGN: At what point is the accuracy not universally acknowledged to be correct? 

SFC: According to the github page that HJS mentioned earlier, there is a point in the 1800s where there were multiple provinces in China that had different rules, and so different competing authorities, and then sometime in the 1800s the Purple Mountain Observatory became the sole authority. 

RGN: Regardless of the longevity of the PMO, there is a point in the 1800s where there would not be universal acknowledgement of the correctness of the Purple Mountain Observatory data?

SFC: Yes, according to that github page. If we define it as the Chinese calendar as given by the PMO, which I have a PR to do, then that’s not a problem.

RGN: Would you know if there was a dispute about the accuracy in, say, 1700?

SFC: I think we would just trust the data published by the PMO in their modern documentation / modern literature, we would just trust the data they have.

RGN: You can pick up material from them and everyone will agree that the material from them has the same values back to, let’s say, 1645.

SFC: I believe so

RGN: So with respect to them as an authority, there’s no question about what they say for that range.

SFC: I believe so

RGN: All of that is background. I actually don’t have a problem with 11 or 12 years being oddly small. It’s fine – it doesn’t matter. What would matter to me is if there is a dispute about accuracy. I think we can derive everything from the one principle that we want to be accurate. If someone says that there was an internal dispute within the PMO and we can only trust their data from 1850 because before them there was a schism, one group says one thing, another another, then that would matter. But that’s not what we have. If we can get back to the 17th century, then, well, let’s do it. All the implementations have the same data available, they can all use them. 

RGN: Conversely, and I’m sure it could be applicable for other calendars, if, before 1912, there were disputes about what’s correct and what’s not, then we can’t go back past 1912 because there is no acknowledged accurate answer. The only mitigating circumstance I see is with regard to data size, which is fuzzy, but I don’t think 1 kb falls within that fuzziness. It’s clearly acceptable – I’m sure I can find 1 kb to trim from any implementation you throw at me.

SFC: I think what RGN said is well-stated. From that basis I’ll say that the thing with the PMO published data is that they have the data published starting at 1900 published freely on their website, but going before then requires going to a library and finding a printed book containing tables before that date. If we say “must match PMO from 1645 onwards” it would require implementations to find data that’s not on the web. If we can find it on the web, then my comment doesn’t apply.

RGN: I agree that that would be an unnecessary implementation burden to require implementors go find data that’s not on the web.

HJS: The data is on the web, on github, by someone who seems to know what they’re doing, but using that data requires trusting that that person did the curation correctly.

RGN: And if the source publishes easily available data from 1900 onwards, then that seems to be the appropriate date. Implementations _may_ go back farther, but we’re not requiring it, because we don’t want to impose an undue burden on implementation in terms of size, trust, or effort. All of those could be disqualifying – and the trust one in particular is a valid argument for not relying on the third-party github data. 

SFC: I really like the “size, trust, and effort” principle – that’s a very good trio. I think that’s enough of a discussion on this topic for today.

### Allow engines to ship data for locales in Accept-Language #1010

https://github.com/tc39/ecma402/issues/1010

HJS: We’re okay with this proposal. 

YSZ: I haven’t had a chance to review this. I need to do a bit more detail about this – this is much more sensitive with regard to fingerprinting, so I can’t say much about it. 

SFC: I think that the next step for this would be to write a PR in that same section of the code that BAN worked on to update it to include this condition. I consider this direction to largely resolve the longstanding open question of how to add additional locales beyond the ones built into the browser. 

---

FYT: Clarification re: intl.localeinfo. I will need the editor group – I’m assuming RGN – to sign off on it

RGN: Any one of the three editors.

FYT: I’ll bring it to your attention when I can. 

