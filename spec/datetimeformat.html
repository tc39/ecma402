<emu-clause id="datetimeformat-objects">
  <h1>DateTimeFormat Objects</h1>

  <emu-clause id="sec-intl-datetimeformat-constructor">
    <h1>The Intl.DateTimeFormat Constructor</h1>

    <p>
      The Intl.DateTimeFormat constructor is the <dfn>%DateTimeFormat%</dfn> intrinsic object and a standard built-in property of the Intl object. Behaviour common to all service constructor properties of the Intl object is specified in <emu-xref href="#sec-internal-slots"></emu-xref>.
    </p>

    <emu-clause id="sec-intl.datetimeformat">
      <h1>Intl.DateTimeFormat ( [ _locales_ [ , _options_ ] ] )</h1>

      <p>
        When the `Intl.DateTimeFormat` function is called with optional arguments _locales_ and _options_, the following steps are taken:
      </p>

      <emu-alg>
        1. If NewTarget is *undefined*, let _newTarget_ be the active function object, else let _newTarget_ be NewTarget.
        1. Let _dateTimeFormat_ be ? CreateDateTimeFormat(_newTarget_, _locales_, _options_, ~any~, ~date~).
        1. If the implementation supports the normative optional constructor mode of <emu-xref href="#legacy-constructor"></emu-xref>, then
          1. Let _this_ be the *this* value.
          1. Return ? ChainDateTimeFormat(_dateTimeFormat_, NewTarget, _this_).
        1. Return _dateTimeFormat_.
      </emu-alg>

      <emu-normative-optional>
      <emu-clause id="sec-chaindatetimeformat" type="abstract operation">
        <h1>
          ChainDateTimeFormat (
            _dateTimeFormat_: an Intl.DateTimeFormat,
            _newTarget_: an ECMAScript language value,
            _this_: an ECMAScript language value,
          ): either a normal completion containing an Object or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _newTarget_ is *undefined* and ? OrdinaryHasInstance(%DateTimeFormat%, _this_) is *true*, then
            1. Perform ? DefinePropertyOrThrow(_this_, %Intl%.[[FallbackSymbol]], PropertyDescriptor{ [[Value]]: _dateTimeFormat_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
            1. Return _this_.
          1. Return _dateTimeFormat_.
        </emu-alg>
      </emu-clause>
      </emu-normative-optional>
    </emu-clause>

    <emu-clause id="sec-createdatetimeformat" type="abstract operation" oldids="sec-initializedatetimeformat,sec-todatetimeoptions">
      <h1>
        CreateDateTimeFormat (
          _newTarget_: a constructor,
          _locales_: an ECMAScript language value,
          _options_: an ECMAScript language value,
          _required_: ~date~, ~time~, or ~any~,
          _defaults_: ~date~, ~time~, or ~all~,
        ): either a normal completion containing a DateTimeFormat object or a throw completion
      </h1>

      <dl class="header">
      </dl>

      <emu-alg>
        1. Let _dateTimeFormat_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%DateTimeFormat.prototype%"*, &laquo; [[InitializedDateTimeFormat]], [[Locale]], [[Calendar]], [[NumberingSystem]], [[TimeZone]], [[Weekday]], [[Era]], [[Year]], [[Month]], [[Day]], [[DayPeriod]], [[Hour]], [[Minute]], [[Second]], [[FractionalSecondDigits]], [[TimeZoneName]], [[HourCycle]], [[DateStyle]], [[TimeStyle]], [[Pattern]], [[RangePatterns]], [[BoundFormat]] &raquo;).
        1. Let _requestedLocales_ be ? CanonicalizeLocaleList(_locales_).
        1. Set _options_ to ? CoerceOptionsToObject(_options_).
        1. Let _opt_ be a new Record.
        1. Let _matcher_ be ? GetOption(_options_, *"localeMatcher"*, ~string~, &laquo; *"lookup"*, *"best fit"* &raquo;, *"best fit"*).
        1. Set _opt_.[[localeMatcher]] to _matcher_.
        1. Let _calendar_ be ? GetOption(_options_, *"calendar"*, ~string~, ~empty~, *undefined*).
        1. If _calendar_ is not *undefined*, then
          1. If _calendar_ cannot be matched by the <code>type</code> Unicode locale nonterminal, throw a *RangeError* exception.
        1. Set _opt_.[[ca]] to _calendar_.
        1. Let _numberingSystem_ be ? GetOption(_options_, *"numberingSystem"*, ~string~, ~empty~, *undefined*).
        1. If _numberingSystem_ is not *undefined*, then
          1. If _numberingSystem_ cannot be matched by the <code>type</code> Unicode locale nonterminal, throw a *RangeError* exception.
        1. Set _opt_.[[nu]] to _numberingSystem_.
        1. Let _hour12_ be ? GetOption(_options_, *"hour12"*, ~boolean~, ~empty~, *undefined*).
        1. Let _hourCycle_ be ? GetOption(_options_, *"hourCycle"*, ~string~, &laquo; *"h11"*, *"h12"*, *"h23"*, *"h24"* &raquo;, *undefined*).
        1. If _hour12_ is not *undefined*, then
          1. Set _hourCycle_ to *null*.
        1. Set _opt_.[[hc]] to _hourCycle_.
        1. Let _localeData_ be %DateTimeFormat%.[[LocaleData]].
        1. Let _r_ be ResolveLocale(%DateTimeFormat%.[[AvailableLocales]], _requestedLocales_, _opt_, %DateTimeFormat%.[[RelevantExtensionKeys]], _localeData_).
        1. Set _dateTimeFormat_.[[Locale]] to _r_.[[locale]].
        1. Let _resolvedCalendar_ be _r_.[[ca]].
        1. Set _dateTimeFormat_.[[Calendar]] to _resolvedCalendar_.
        1. Set _dateTimeFormat_.[[NumberingSystem]] to _r_.[[nu]].
        1. Let _dataLocale_ be _r_.[[dataLocale]].
        1. Let _dataLocaleData_ be _localeData_.[[&lt;_dataLocale_&gt;]].
        1. If _hour12_ is *true*, then
          1. Let _hc_ be _dataLocaleData_.[[hourCycle12]].
        1. Else if _hour12_ is *false*, then
          1. Let _hc_ be _dataLocaleData_.[[hourCycle24]].
        1. Else,
          1. Assert: _hour12_ is *undefined*.
          1. Let _hc_ be _r_.[[hc]].
          1. If _hc_ is *null*, set _hc_ to _dataLocaleData_.[[hourCycle]].
        1. Set _dateTimeFormat_.[[HourCycle]] to _hc_.
        1. Let _timeZone_ be ? Get(_options_, *"timeZone"*).
        1. If _timeZone_ is *undefined*, then
          1. Set _timeZone_ to SystemTimeZoneIdentifier().
        1. Else,
          1. Set _timeZone_ to ? ToString(_timeZone_).
        1. If IsTimeZoneOffsetString(_timeZone_) is *true*, then
          1. Let _parseResult_ be ParseText(StringToCodePoints(_timeZone_), |UTCOffset|).
          1. Assert: _parseResult_ is a Parse Node.
          1. If _parseResult_ contains more than one |MinuteSecond| Parse Node, throw a *RangeError* exception.
          1. Let _offsetNanoseconds_ be ParseTimeZoneOffsetString(_timeZone_).
          1. Let _offsetMinutes_ be _offsetNanoseconds_ / (6 × 10<sup>10</sup>).
          1. Assert: _offsetMinutes_ is an integer.
          1. Set _timeZone_ to FormatOffsetTimeZoneIdentifier(_offsetMinutes_).
        1. Else if IsValidTimeZoneName(_timeZone_) is *true*, then
          1. Set _timeZone_ to CanonicalizeTimeZoneName(_timeZone_).
        1. Else,
          1. Throw a *RangeError* exception.
        1. Set _dateTimeFormat_.[[TimeZone]] to _timeZone_.
        1. Let _formatOptions_ be a new Record.
        1. Set _formatOptions_.[[hourCycle]] to _hc_.
        1. Let _hasExplicitFormatComponents_ be *false*.
        1. For each row of <emu-xref href="#table-datetimeformat-components"></emu-xref>, except the header row, in table order, do
          1. Let _prop_ be the name given in the Property column of the row.
          1. If _prop_ is *"fractionalSecondDigits"*, then
            1. Let _value_ be ? GetNumberOption(_options_, *"fractionalSecondDigits"*, 1, 3, *undefined*).
          1. Else,
            1. Let _values_ be a List whose elements are the strings given in the Values column of the row.
            1. Let _value_ be ? GetOption(_options_, _prop_, ~string~, _values_, *undefined*).
          1. Set _formatOptions_.[[&lt;_prop_&gt;]] to _value_.
          1. If _value_ is not *undefined*, then
            1. Set _hasExplicitFormatComponents_ to *true*.
        1. Let _formatMatcher_ be ? GetOption(_options_, *"formatMatcher"*, ~string~, &laquo; *"basic"*, *"best fit"* &raquo;, *"best fit"*).
        1. Let _dateStyle_ be ? GetOption(_options_, *"dateStyle"*, ~string~, &laquo; *"full"*, *"long"*, *"medium"*, *"short"* &raquo;, *undefined*).
        1. Set _dateTimeFormat_.[[DateStyle]] to _dateStyle_.
        1. Let _timeStyle_ be ? GetOption(_options_, *"timeStyle"*, ~string~, &laquo; *"full"*, *"long"*, *"medium"*, *"short"* &raquo;, *undefined*).
        1. Set _dateTimeFormat_.[[TimeStyle]] to _timeStyle_.
        1. If _dateStyle_ is not *undefined* or _timeStyle_ is not *undefined*, then
          1. If _hasExplicitFormatComponents_ is *true*, then
            1. Throw a *TypeError* exception.
          1. If _required_ is ~date~ and _timeStyle_ is not *undefined*, then
            1. Throw a *TypeError* exception.
          1. If _required_ is ~time~ and _dateStyle_ is not *undefined*, then
            1. Throw a *TypeError* exception.
          1. Let _styles_ be _dataLocaleData_.[[styles]].[[&lt;_resolvedCalendar_&gt;]].
          1. Let _bestFormat_ be DateTimeStyleFormat(_dateStyle_, _timeStyle_, _styles_).
        1. Else,
          1. Let _needDefaults_ be *true*.
          1. If _required_ is ~date~ or ~any~, then
            1. For each property name _prop_ of &laquo; *"weekday"*, *"year"*, *"month"*, *"day"* &raquo;, do
              1. Let _value_ be _formatOptions_.[[&lt;_prop_&gt;]].
              1. If _value_ is not *undefined*, set _needDefaults_ to *false*.
          1. If _required_ is ~time~ or ~any~, then
            1. For each property name _prop_ of &laquo; *"dayPeriod"*, *"hour"*, *"minute"*, *"second"*, *"fractionalSecondDigits"* &raquo;, do
              1. Let _value_ be _formatOptions_.[[&lt;_prop_&gt;]].
              1. If _value_ is not *undefined*, set _needDefaults_ to *false*.
          1. If _needDefaults_ is *true* and _defaults_ is either ~date~ or ~all~, then
            1. For each property name _prop_ of &laquo; *"year"*, *"month"*, *"day"* &raquo;, do
              1. Set _formatOptions_.[[&lt;_prop_&gt;]] to *"numeric"*.
          1. If _needDefaults_ is *true* and _defaults_ is either ~time~ or ~all~, then
            1. For each property name _prop_ of &laquo; *"hour"*, *"minute"*, *"second"* &raquo;, do
              1. Set _formatOptions_.[[&lt;_prop_&gt;]] to *"numeric"*.
          1. Let _formats_ be _dataLocaleData_.[[formats]].[[&lt;_resolvedCalendar_&gt;]].
          1. If _formatMatcher_ is *"basic"*, then
            1. Let _bestFormat_ be BasicFormatMatcher(_formatOptions_, _formats_).
          1. Else,
            1. Let _bestFormat_ be BestFitFormatMatcher(_formatOptions_, _formats_).
        1. For each row in <emu-xref href="#table-datetimeformat-components"></emu-xref>, except the header row, in table order, do
          1. Let _prop_ be the name given in the Property column of the row.
          1. If _bestFormat_ has a field [[&lt;_prop_&gt;]], then
            1. Let _p_ be _bestFormat_.[[&lt;_prop_&gt;]].
            1. Set _dateTimeFormat_'s internal slot whose name is the Internal Slot column of the row to _p_.
        1. If _dateTimeFormat_.[[Hour]] is *undefined*, then
          1. Set _dateTimeFormat_.[[HourCycle]] to *undefined*.
        1. If _dateTimeFormat_.[[HourCycle]] is *"h11"* or *"h12"*, then
          1. Let _pattern_ be _bestFormat_.[[pattern12]].
          1. Let _rangePatterns_ be _bestFormat_.[[rangePatterns12]].
        1. Else,
          1. Let _pattern_ be _bestFormat_.[[pattern]].
          1. Let _rangePatterns_ be _bestFormat_.[[rangePatterns]].
        1. Set _dateTimeFormat_.[[Pattern]] to _pattern_.
        1. Set _dateTimeFormat_.[[RangePatterns]] to _rangePatterns_.
        1. Return _dateTimeFormat_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatoffsettimezoneidentifier" type="abstract operation">
      <h1>
        FormatOffsetTimeZoneIdentifier (
          _offsetMinutes_: an integer,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It formats a UTC offset, in minutes, into a UTC offset string formatted like ±HH:MM.
        </dd>
      </dl>
      <emu-alg>
        1. If _offsetMinutes_ &ge; 0, let _sign_ be the code unit 0x002B (PLUS SIGN); otherwise, let _sign_ be the code unit 0x002D (HYPHEN-MINUS).
        1. Let _absoluteMinutes_ be abs(_offsetMinutes_).
        1. Let _hours_ be floor(_absoluteMinutes_ / 60).
        1. Let _minutes_ be _absoluteMinutes_ modulo 60.
        1. Return the string-concatenation of _sign_, ToZeroPaddedDecimalString(_hours_, 2), the code unit 0x003A (COLON), and ToZeroPaddedDecimalString(_minutes_, 2).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-datetimeformat-constructor">
    <h1>Properties of the Intl.DateTimeFormat Constructor</h1>

    <p>
      The Intl.DateTimeFormat constructor has the following properties:
    </p>

    <emu-clause id="sec-intl.datetimeformat.prototype">
      <h1>Intl.DateTimeFormat.prototype</h1>

      <p>
        The value of `Intl.DateTimeFormat.prototype` is %DateTimeFormat.prototype%.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-intl.datetimeformat.supportedlocalesof">
      <h1>Intl.DateTimeFormat.supportedLocalesOf ( _locales_ [ , _options_ ] )</h1>

      <p>
        When the `supportedLocalesOf` method is called with arguments _locales_ and _options_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _availableLocales_ be %DateTimeFormat%.[[AvailableLocales]].
        1. Let _requestedLocales_ be ? CanonicalizeLocaleList(_locales_).
        1. Return ? SupportedLocales(_availableLocales_, _requestedLocales_, _options_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-intl.datetimeformat-internal-slots">
      <h1>Internal slots</h1>

      <p>
        The value of the [[AvailableLocales]] internal slot is implementation-defined within the constraints described in <emu-xref href="#sec-internal-slots"></emu-xref>.
      </p>

      <p>
        The value of the [[RelevantExtensionKeys]] internal slot is &laquo; *"ca"*, *"hc"*, *"nu"* &raquo;.
      </p>

      <emu-note>
        <a href="https://unicode.org/reports/tr35/#Key_Type_Definitions">Unicode Technical Standard #35 Part 1 Core, Section 3.6.1 Key and Type Definitions</a> describes four locale extension keys that are relevant to date and time formatting: *"ca"* for calendar, *"hc"* for hour cycle, *"nu"* for numbering system (of formatted numbers), and *"tz"* for time zone. DateTimeFormat, however, requires that the time zone is specified through the *"timeZone"* property in the options objects.
      </emu-note>

      <p>
        The value of the [[LocaleData]] internal slot is implementation-defined within the constraints described in <emu-xref href="#sec-internal-slots"></emu-xref> and the following additional constraints, for all locale values _locale_:
      </p>

      <ul>
        <li>
          [[LocaleData]].[[&lt;_locale_&gt;]].[[nu]] must be a List that does not include the values *"native"*, *"traditio"*, or *"finance"*.
        </li>
        <li>
          [[LocaleData]].[[&lt;_locale_&gt;]].[[hc]] must be &laquo; *null*, *"h11"*, *"h12"*, *"h23"*, *"h24"* &raquo;.
        </li>
        <li>
          [[LocaleData]].[[&lt;_locale_&gt;]].[[hourCycle]] must be a String value equal to *"h11"*, *"h12"*, *"h23"*, or *"h24"*.
        </li>
        <li>
          [[LocaleData]].[[&lt;_locale_&gt;]].[[hourCycle12]] must be a String value equal to *"h11"* or *"h12"*.
        </li>
        <li>
          [[LocaleData]].[[&lt;_locale_&gt;]].[[hourCycle24]] must be a String value equal to *"h23"* or *"h24"*.
        </li>
        <li>
          [[LocaleData]].[[&lt;_locale_&gt;]] must have a [[formats]] field. This [[formats]] field must be a Record with [[&lt;_calendar_&gt;]] fields for all calendar values _calendar_. The value of this field must be a list of records, each of which has a subset of the fields shown in <emu-xref href="#table-datetimeformat-components"></emu-xref>, where each field must have one of the values specified for the field in <emu-xref href="#table-datetimeformat-components"></emu-xref>. Multiple records in a list may use the same subset of the fields as long as they have different values for the fields. The following subsets must be available for each locale:
          <ul>
            <li>weekday, year, month, day, hour, minute, second, fractionalSecondDigits</li>
            <li>weekday, year, month, day, hour, minute, second</li>
            <li>weekday, year, month, day</li>
            <li>year, month, day</li>
            <li>year, month</li>
            <li>month, day</li>
            <li>hour, minute, second, fractionalSecondDigits</li>
            <li>hour, minute, second</li>
            <li>hour, minute</li>
            <li>dayPeriod, hour</li>
            <li>dayPeriod, hour, minute, second</li>
            <li>dayPeriod, hour, minute</li>
          </ul>
          Each of the records must also have the following fields:
          <ol>
            <li>A [[pattern]] field, whose value is a String value that contains for each of the date and time format component fields of the record a substring starting with *"{"*, followed by the name of the field, followed by *"}"*.</li>
            <li>If the record has an [[hour]] field, it must also have a [[pattern12]] field, whose value is a String value that, in addition to the substrings of the [[pattern]] field, contains at least one of the substrings *"{ampm}"* or *"{dayPeriod}"*.</li>
            <li>If the record has a [[year]] field, the [[pattern]] and [[pattern12]] values may contain the substrings *"{yearName}"* and *"{relatedYear}"*.</li>
            <li>
              A [[rangePatterns]] field with a Record value:
                <ul>
                  <li>The [[rangePatterns]] record may have any of the fields in <emu-xref href="#table-datetimeformat-rangepatternfields"></emu-xref>, where each field represents a range pattern and its value is a Record.
                    <ul>
                      <li>The name of the field indicates the largest calendar element that must be different between the start and end dates in order to use this range pattern. For example, if the field name is [[Month]], it contains the range pattern that should be used to format a date range where the era and year values are the same, but the month value is different.</li>
                      <li>The record will contain the following fields:</li>
                        <ul>
                          <li>A subset of the fields shown in the Property column of <emu-xref href="#table-datetimeformat-components"></emu-xref>, where each field must have one of the values specified for that field in the Values column of <emu-xref href="#table-datetimeformat-components"></emu-xref>. All fields required to format a date for any of the [[PatternParts]] records must be present.</li>
                          <li>A [[PatternParts]] field whose value is a list of Records each representing a part of the range pattern. Each record contains a [[Pattern]] field and a [[Source]] field. The [[Pattern]] field's value is a String of the same format as the regular date pattern String. The [[Source]] field is one of the String values *"shared"*, *"startRange"*, or *"endRange"*. It indicates which of the range's dates should be formatted using the value of the [[Pattern]] field.</li>
                        </ul>
                    </ul>
                  </li>
                  <li>The [[rangePatterns]] record must have a [[Default]] field which contains the default range pattern used when the specific range pattern is not available. Its value is a list of records with the same structure as the other fields in the [[rangePatterns]] record.</li>
                </ul>
            </li>
            <li>If the record has an [[hour]] field, it must also have a [[rangePatterns12]] field. Its value is similar to the Record in [[rangePatterns]], but it uses a String similar to [[pattern12]] for each part of the range pattern.</li>
            <li>If the record has a [[year]] field, the [[rangePatterns]] and [[rangePatterns12]] fields may contain range patterns where the [[Pattern]] values may contain the substrings *"{yearName}"* and *"{relatedYear}"*.</li>
          </ol>
        </li>
        <li>
          [[LocaleData]].[[&lt;_locale_&gt;]] must have a [[styles]] field. The [[styles]] field must be a Record with [[&lt;_calendar_&gt;]] fields for all calendar values _calendar_. The calendar records must contain [[DateFormat]], [[TimeFormat]], [[DateTimeFormat]] and [[DateTimeRangeFormat]] fields, the value of these fields are Records, where each of which has [[full]], [[long]], [[medium]] and [[short]] fields. For [[DateFormat]] and [[TimeFormat]], the value of these fields must be a record, which has a subset of the fields shown in <emu-xref href="#table-datetimeformat-components"></emu-xref>, where each field must have one of the values specified for the field in <emu-xref href="#table-datetimeformat-components"></emu-xref>. Each of the records must also have the following fields:
          <ol>
            <li>A [[pattern]] field, whose value is a String value that contains for each of the date and time format component fields of the record a substring starting with *"{"*, followed by the name of the field, followed by *"}"*.</li>
            <li>If the record has an [[hour]] field, it must also have a [[pattern12]] field, whose value is a String value that, in addition to the substrings of the pattern field, contains at least one of the substrings *"{ampm}"* or *"{dayPeriod}"*.</li>
            <li>A [[rangePatterns]] field that contains a record similar to the one described in the [[formats]] field.</li>
            <li>If the record has an [[hour]] field, it must also have a [[rangePatterns12]] field. Its value is similar to the record in [[rangePatterns]] but it uses a string similar to [[pattern12]] for each range pattern.</li>
          </ol>
          For [[DateTimeFormat]], the field value must be a string pattern which contains the strings *"{0}"* and *"{1}"*. For [[DateTimeRangeFormat]] the value of these fields must be a nested record which also has [[full]], [[long]], [[medium]] and [[short]] fields. The [[full]], [[long]], [[medium]] and [[short]] fields in the enclosing record refer to the date style of the range pattern, while the fields in the nested record refers to the time style of the range pattern. The value of these fields in the nested record is a record with a [[rangePatterns]] field and a [[rangePatterns12]] field which are similar to the [[rangePatterns]] and [rangePatterns12]] fields in [[DateFormat]] and [[TimeFormat]].
         </li>
      </ul>

      <emu-note>
        For example, an implementation might include the following record as part of its English locale data:
        <ul>
          <li>[[hour]]: *"numeric"*</li>
          <li>[[minute]]: *"numeric"*</li>
          <li>[[pattern]]: *"{hour}:{minute}"*</li>
          <li>[[pattern12]]: *"{hour}:{minute} {ampm}"*</li>
          <li>[[rangePatterns]]:</li>
          <ul>
            <li>[[Hour]]:<ul>
              <li>[[hour]]: *"numeric"*</li>
              <li>[[minute]]: *"numeric"*</li>
              <li>[[PatternParts]]:</li>
              <ul>
                <li>{[[Source]]: *"startRange"*, [[Pattern]]: *"{hour}:{minute}"*}</li>
                <li>{[[Source]]: *"shared"*, [[Pattern]]: *" – "*}</li>
                <li>{[[Source]]: *"endRange"*, [[Pattern]]: *"{hour}:{minute}"*}</li>
              </ul>
            </ul></li>
            <li>[[Minute]]:<ul>
              <li>[[hour]]: *"numeric"*</li>
              <li>[[minute]]: *"numeric"*</li>
              <li>[[PatternParts]]:</li>
              <ul>
                <li>{[[Source]]: *"startRange"*, [[Pattern]]: *"{hour}:{minute}"*}</li>
                <li>{[[Source]]: *"shared"*, [[Pattern]]: *" – "*}</li>
                <li>{[[Source]]: *"endRange"*, [[Pattern]]: *"{hour}:{minute}"*}</li>
              </ul>
            </ul></li>
            <li>[[Default]]:<ul>
              <li>[[year]]: *"2-digit"*</li>
              <li>[[month]]: *"numeric"*</li>
              <li>[[day]]: *"numeric"*</li>
              <li>[[hour]]: *"numeric"*</li>
              <li>[[minute]]: *"numeric"*</li>
              <li>[[PatternParts]]:</li>
              <ul>
                <li>{[[Source]]: *"startRange"*, [[Pattern]]: *"{day}/{month}/{year}, {hour}:{minute}"*}</li>
                <li>{[[Source]]: *"shared"*, [[Pattern]]: *" – "*}</li>
                <li>{[[Source]]: *"endRange"*, [[Pattern]]: *"{day}/{month}/{year}, {hour}:{minute}"*}</li>
              </ul>
            </ul></li>
          </ul>
          <li>[[rangePatterns12]]:
          <ul>
            <li>[[Hour]]:<ul>
              <li>[[hour]]: *"numeric"*</li>
              <li>[[minute]]: *"numeric"*</li>
              <li>[[PatternParts]]:</li>
              <ul>
                <li>{[[Source]]: *"startRange"*, [[Pattern]]: *"{hour}:{minute}"*}</li>
                <li>{[[Source]]: *"shared"*, [[Pattern]]: *" – "*}</li>
                <li>{[[Source]]: *"endRange"*, [[Pattern]]: *"{hour}:{minute}"*}</li>
                <li>{[[Source]]: *"shared"*, [[Pattern]]: *" {ampm}"*}</li>
              </ul>
            </ul></li>
            <li>[[Minute]]:<ul>
              <li>[[hour]]: *"numeric"*</li>
              <li>[[minute]]: *"numeric"*</li>
              <li>[[PatternParts]]:</li>
              <ul>
                <li>{[[Source]]: *"startRange"*, [[Pattern]]: *"{hour}:{minute}"*}</li>
                <li>{[[Source]]: *"shared"*, [[Pattern]]: *" – "*}</li>
                <li>{[[Source]]: *"endRange"*, [[Pattern]]: *"{hour}:{minute}"*}</li>
                <li>{[[Source]]: *"shared"*, [[Pattern]]: *" {ampm}"*}</li>
              </ul>
            </ul></li>
            <li>[[Default]]:<ul>
              <li>[[year]]: *"2-digit"*</li>
              <li>[[month]]: *"numeric"*</li>
              <li>[[day]]: *"numeric"*</li>
              <li>[[hour]]: *"numeric"*</li>
              <li>[[minute]]: *"numeric"*</li>
              <li>[[PatternParts]]:</li>
              <ul>
                <li>{[[Source]]: *"startRange"*, [[Pattern]]: *"{day}/{month}/{year}, {hour}:{minute} {ampm}"*}</li>
                <li>{[[Source]]: *"shared"*, [[Pattern]]: *" – "*}</li>
                <li>{[[Source]]: *"endRange"*, [[Pattern]]: *"{day}/{month}/{year}, {hour}:{minute} {ampm}"*}</li>
              </ul>
            </ul></li>
          </ul></li>
        </ul>
      </emu-note>

      <emu-note>
        It is recommended that implementations use the locale data provided by the Common Locale Data Repository (available at <a href="https://cldr.unicode.org/">https://cldr.unicode.org/</a>).
      </emu-note>

      <emu-table id="table-datetimeformat-rangepatternfields">
        <emu-caption>Range pattern fields</emu-caption>

        <table class="real-table">
          <thead>
            <tr>
              <th>Range Pattern Field</th>
              <th>Pattern String Field</th>
            </tr>
          </thead>
          <tr>
            <td>[[Era]]</td>
            <td>*"era"*</td>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>*"year"*</td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>*"month"*</td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>*"day"*</td>
          </tr>
          <tr>
            <td>[[AmPm]]</td>
            <td>*"ampm"*</td>
          </tr>
          <tr>
            <td>[[DayPeriod]]</td>
            <td>*"dayPeriod"*</td>
          </tr>
          <tr>
            <td>[[Hour]]</td>
            <td>*"hour"*</td>
          </tr>
          <tr>
            <td>[[Minute]]</td>
            <td>*"minute"*</td>
          </tr>
          <tr>
            <td>[[Second]]</td>
            <td>*"second"*</td>
          </tr>
          <tr>
            <td>[[FractionalSecondDigits]]</td>
            <td>*"fractionalSecondDigits"*</td>
          </tr>
        </table>

      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-datetimeformat-prototype-object">
    <h1>Properties of the Intl.DateTimeFormat Prototype Object</h1>

    <p>
      The Intl.DateTimeFormat prototype object is itself an ordinary object. <dfn>%DateTimeFormat.prototype%</dfn> is not an Intl.DateTimeFormat instance and does not have an [[InitializedDateTimeFormat]] internal slot or any of the other internal slots of Intl.DateTimeFormat instance objects.
    </p>

    <emu-clause id="sec-intl.datetimeformat.prototype.constructor">
      <h1>Intl.DateTimeFormat.prototype.constructor</h1>

      <p>
        The initial value of `Intl.DateTimeFormat.prototype.constructor` is %DateTimeFormat%.
      </p>
    </emu-clause>

    <emu-clause id="sec-intl.datetimeformat.prototype-@@tostringtag">
      <h1>Intl.DateTimeFormat.prototype [ @@toStringTag ]</h1>

      <p>
        The initial value of the @@toStringTag property is the String value *"Intl.DateTimeFormat"*.
      </p>

      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-intl.datetimeformat.prototype.format">
      <h1>get Intl.DateTimeFormat.prototype.format</h1>

      <p>
        Intl.DateTimeFormat.prototype.format is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:
      </p>

      <emu-alg>
        1. Let _dtf_ be the *this* value.
        1. If the implementation supports the normative optional constructor mode of <emu-xref href="#legacy-constructor"></emu-xref>, then
          1. Set _dtf_ to ? UnwrapDateTimeFormat(_dtf_).
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. If _dtf_.[[BoundFormat]] is *undefined*, then
          1. Let _F_ be a new built-in function object as defined in DateTime Format Functions (<emu-xref href="#sec-datetime-format-functions"></emu-xref>).
          1. Set _F_.[[DateTimeFormat]] to _dtf_.
          1. Set _dtf_.[[BoundFormat]] to _F_.
        1. Return _dtf_.[[BoundFormat]].
      </emu-alg>

      <emu-note>
        The returned function is bound to _dtf_ so that it can be passed directly to `Array.prototype.map` or other functions.
        This is considered a historical artefact, as part of a convention which is no longer followed for new features, but is preserved to maintain compatibility with existing programs.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-Intl.DateTimeFormat.prototype.formatToParts">
      <h1>Intl.DateTimeFormat.prototype.formatToParts ( _date_ )</h1>

      <p>
        When the `formatToParts` method is called with an argument _date_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _dtf_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. If _date_ is *undefined*, then
          1. Let _x_ be ! Call(%Date.now%, *undefined*).
        1. Else,
          1. Let _x_ be ? ToNumber(_date_).
        1. Return ? FormatDateTimeToParts(_dtf_, _x_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-intl.datetimeformat.prototype.formatRange">
      <h1>Intl.DateTimeFormat.prototype.formatRange ( _startDate_, _endDate_ )</h1>

      <p>
        When the `formatRange` method is called with arguments _startDate_ and _endDate_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _dtf_ be *this* value.
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. If _startDate_ is *undefined* or _endDate_ is *undefined*, throw a *TypeError* exception.
        1. Let _x_ be ? ToNumber(_startDate_).
        1. Let _y_ be ? ToNumber(_endDate_).
        1. Return ? FormatDateTimeRange(_dtf_, _x_, _y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.DateTimeFormat.prototype.formatRangeToParts">
      <h1>Intl.DateTimeFormat.prototype.formatRangeToParts ( _startDate_, _endDate_ )</h1>

      <p>
        When the `formatRangeToParts` method is called with arguments _startDate_ and _endDate_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _dtf_ be *this* value.
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. If _startDate_ is *undefined* or _endDate_ is *undefined*, throw a *TypeError* exception.
        1. Let _x_ be ? ToNumber(_startDate_).
        1. Let _y_ be ? ToNumber(_endDate_).
        1. Return ? FormatDateTimeRangeToParts(_dtf_, _x_, _y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-intl.datetimeformat.prototype.resolvedoptions">
      <h1>Intl.DateTimeFormat.prototype.resolvedOptions ( )</h1>

      <p>
        This function provides access to the locale and options computed during initialization of the object.
      </p>

      <emu-alg>
        1. Let _dtf_ be the *this* value.
        1. If the implementation supports the normative optional constructor mode of <emu-xref href="#legacy-constructor"></emu-xref>, then
          1. Set _dtf_ to ? UnwrapDateTimeFormat(_dtf_).
        1. Perform ? RequireInternalSlot(_dtf_, [[InitializedDateTimeFormat]]).
        1. Let _options_ be OrdinaryObjectCreate(%Object.prototype%).
        1. For each row of <emu-xref href="#table-datetimeformat-resolvedoptions-properties"></emu-xref>, except the header row, in table order, do
          1. Let _v_ be the value of _dtf_'s internal slot whose name is the Internal Slot value of the current row.
          1. Let _p_ be the Property value of the current row.
          1. If the Internal Slot value of the current row is an Internal Slot value in <emu-xref href="#table-datetimeformat-components"></emu-xref>, then
            1. If _dtf_.[[DateStyle]] is not *undefined* or _dtf_.[[TimeStyle]] is not *undefined*, then
              1. Set _v_ to *undefined*.
          1. If _v_ is not *undefined*, then
            1. If there is a Conversion value in the current row, then
              1. Let _conversion_ be the Conversion value of the current row.
              1. If _conversion_ is ~hour12~, then
                1. If _v_ is *"h11"* or *"h12"*, set _v_ to *true*. Otherwise, set _v_ to *false*.
              1. Else,
                1. Assert: _conversion_ is ~number~.
                1. Set _v_ to 𝔽(_v_).
            1. Perform ! CreateDataPropertyOrThrow(_options_, _p_, _v_).
        1. Return _options_.
      </emu-alg>

      <emu-table id="table-datetimeformat-resolvedoptions-properties">
        <emu-caption>Resolved Options of DateTimeFormat Instances</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Property</th>
              <th>Conversion</th>
            </tr>
          </thead>
          <tr>
            <td>[[Locale]]</td>
            <td>*"locale"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[Calendar]]</td>
            <td>*"calendar"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[NumberingSystem]]</td>
            <td>*"numberingSystem"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[TimeZone]]</td>
            <td>*"timeZone"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[HourCycle]]</td>
            <td>*"hourCycle"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[HourCycle]]</td>
            <td>*"hour12"*</td>
            <td>~hour12~</td>
          </tr>
          <tr>
            <td>[[Weekday]]</td>
            <td>*"weekday"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[Era]]</td>
            <td>*"era"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>*"year"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>*"month"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>*"day"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[DayPeriod]]</td>
            <td>*"dayPeriod"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[Hour]]</td>
            <td>*"hour"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[Minute]]</td>
            <td>*"minute"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[Second]]</td>
            <td>*"second"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[FractionalSecondDigits]]</td>
            <td>*"fractionalSecondDigits"*</td>
            <td>~number~</td>
          </tr>
          <tr>
            <td>[[TimeZoneName]]</td>
            <td>*"timeZoneName"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[DateStyle]]</td>
            <td>*"dateStyle"*</td>
            <td></td>
          </tr>
          <tr>
            <td>[[TimeStyle]]</td>
            <td>*"timeStyle"*</td>
            <td></td>
          </tr>
        </table>
      </emu-table>

      <p>
        For web compatibility reasons, if the property *"hourCycle"* is set, the *"hour12"* property should be set to *true* when *"hourCycle"* is *"h11"* or *"h12"*, or to *false* when *"hourCycle"* is *"h23"* or *"h24"*.
      </p>

      <emu-note>
        In this version of the API, the *"timeZone"* property will be the identifier of the host environment's time zone if no *"timeZone"* property was provided in the options object provided to the Intl.DateTimeFormat constructor. The first edition left the *"timeZone"* property *undefined* in this case.
      </emu-note>

      <emu-note>
        For compatibility with versions prior to the fifth edition, the *"hour12"* property is set in addition to the *"hourCycle"* property.
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-datetimeformat-instances">
    <h1>Properties of Intl.DateTimeFormat Instances</h1>

    <p>
      Intl.DateTimeFormat instances are ordinary objects that inherit properties from %DateTimeFormat.prototype%.
    </p>

    <p>
      Intl.DateTimeFormat instances have an [[InitializedDateTimeFormat]] internal slot.
    </p>

    <p>
      Intl.DateTimeFormat instances also have several internal slots that are computed by the constructor:
    </p>

    <ul>
      <li>[[Locale]] is a String value with the language tag of the locale whose localization is used for formatting.</li>
      <li>[[Calendar]] is a String value representing the <a href="https://unicode.org/reports/tr35/#UnicodeCalendarIdentifier">Unicode Calendar Identifier</a> used for formatting.</li>
      <li>[[NumberingSystem]] is a String value representing the <a href="https://unicode.org/reports/tr35/#UnicodeNumberSystemIdentifier">Unicode Number System Identifier</a> used for formatting.</li>
      <li>[[TimeZone]] is a String value used for formatting that is either a time zone identifier from the IANA Time Zone Database or a UTC offset in ISO 8601 extended format.</li>
      <li>[[Weekday]], [[Era]], [[Year]], [[Month]], [[Day]], [[DayPeriod]], [[Hour]], [[Minute]], [[Second]], [[TimeZoneName]] are each either *undefined*, indicating that the component is not used for formatting, or one of the String values given in <emu-xref href="#table-datetimeformat-components"></emu-xref>, indicating how the component should be presented in the formatted output.</li>
      <li>[[FractionalSecondDigits]] is either *undefined* or a positive, non-zero integer indicating the fraction digits to be used for fractional seconds. Numbers will be rounded or padded with trailing zeroes if necessary.</li>
      <li>[[HourCycle]] is a String value indicating whether the 12-hour format (*"h11"*, *"h12"*) or the 24-hour format (*"h23"*, *"h24"*) should be used. *"h11"* and *"h23"* start with hour 0 and go up to 11 and 23 respectively. *"h12"* and *"h24"* start with hour 1 and go up to 12 and 24. [[HourCycle]] is only used when [[Hour]] is not *undefined*.</li>
      <li>[[DateStyle]], [[TimeStyle]] are each either *undefined*, or a String value with values *"full"*, *"long"*, *"medium"*, or *"short"*.</li>
      <li>[[Pattern]] is a String value as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>.</li>
      <li>[[RangePatterns]] is a Record as described in <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>.</li>
    </ul>

    <p>
      Finally, Intl.DateTimeFormat instances have a [[BoundFormat]] internal slot that caches the function returned by the format accessor (<emu-xref href="#sec-intl.datetimeformat.prototype.format"></emu-xref>).
    </p>
  </emu-clause>

  <emu-clause id="sec-datetimeformat-abstracts">
    <h1>Abstract Operations for DateTimeFormat Objects</h1>

    <p>
      Several DateTimeFormat algorithms use values from the following table, which provides internal slots, property names and allowable values for the components of date and time formats:
    </p>

    <emu-table id="table-datetimeformat-components">
      <emu-caption>Components of date and time formats</emu-caption>
      <table class="real-table">
        <thead>
          <tr>
            <th>Internal Slot</th>
            <th>Property</th>
            <th>Values</th>
          </tr>
        </thead>
        <tr>
          <td>[[Weekday]]</td>
          <td>*"weekday"*</td>
          <td>*"narrow"*, *"short"*, *"long"*</td>
        </tr>
        <tr>
          <td>[[Era]]</td>
          <td>*"era"*</td>
          <td>*"narrow"*, *"short"*, *"long"*</td>
        </tr>
        <tr>
          <td>[[Year]]</td>
          <td>*"year"*</td>
          <td>*"2-digit"*, *"numeric"*</td>
        </tr>
        <tr>
          <td>[[Month]]</td>
          <td>*"month"*</td>
          <td>*"2-digit"*, *"numeric"*, *"narrow"*, *"short"*, *"long"*</td>
        </tr>
        <tr>
          <td>[[Day]]</td>
          <td>*"day"*</td>
          <td>*"2-digit"*, *"numeric"*</td>
        </tr>
        <tr>
          <td>[[DayPeriod]]</td>
          <td>*"dayPeriod"*</td>
          <td>*"narrow"*, *"short"*, *"long"*</td>
        </tr>
        <tr>
          <td>[[Hour]]</td>
          <td>*"hour"*</td>
          <td>*"2-digit"*, *"numeric"*</td>
        </tr>
        <tr>
          <td>[[Minute]]</td>
          <td>*"minute"*</td>
          <td>*"2-digit"*, *"numeric"*</td>
        </tr>
        <tr>
          <td>[[Second]]</td>
          <td>*"second"*</td>
          <td>*"2-digit"*, *"numeric"*</td>
        </tr>
        <tr>
          <td>[[FractionalSecondDigits]]</td>
          <td>*"fractionalSecondDigits"*</td>
          <td>1, 2, 3</td>
        </tr>
        <tr>
          <td>[[TimeZoneName]]</td>
          <td>*"timeZoneName"*</td>
          <td>*"short"*, *"long"*, *"shortOffset"*, *"longOffset"*, *"shortGeneric"*, *"longGeneric"*</td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-date-time-style-format" type="abstract operation">
      <h1>
        DateTimeStyleFormat (
          _dateStyle_: *"full"*, *"long"*, *"medium"*, *"short"*, or *undefined*,
          _timeStyle_: *"full"*, *"long"*, *"medium"*, *"short"*, or *undefined*,
          _styles_: a Record,
        ): a Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_styles_ is a record from %DateTimeFormat%.[[LocaleData]].[[&lt;_locale_&gt;]].[[styles]].[[&lt;_calendar_&gt;]] for some locale _locale_ and calendar _calendar_. It returns the appropriate format record for date time formatting based on the parameters.</dd>
      </dl>
      <emu-alg>
        1. Assert: _dateStyle_ is not *undefined* or _timeStyle_ is not *undefined*.
        1. If _timeStyle_ is not *undefined*, then
          1. Assert: _timeStyle_ is one of *"full"*, *"long"*, *"medium"*, or *"short"*.
          1. Let _timeFormat_ be _styles_.[[TimeFormat]].[[&lt;_timeStyle_&gt;]].
        1. If _dateStyle_ is not *undefined*, then
          1. Assert: _dateStyle_ is one of *"full"*, *"long"*, *"medium"*, or *"short"*.
          1. Let _dateFormat_ be _styles_.[[DateFormat]].[[&lt;_dateStyle_&gt;]].
        1. If _dateStyle_ is not *undefined* and _timeStyle_ is not *undefined*, then
          1. Let _format_ be a new Record.
          1. Add to _format_ all fields from _dateFormat_ except [[pattern]] and [[rangePatterns]].
          1. Add to _format_ all fields from _timeFormat_ except [[pattern]], [[rangePatterns]], [[pattern12]], and [[rangePatterns12]], if present.
          1. Let _connector_ be _styles_.[[DateTimeFormat]].[[&lt;_dateStyle_&gt;]].
          1. Let _pattern_ be the string _connector_ with the substring *"{0}"* replaced with _timeFormat_.[[pattern]] and the substring *"{1}"* replaced with _dateFormat_.[[pattern]].
          1. Set _format_.[[pattern]] to _pattern_.
          1. If _timeFormat_ has a [[pattern12]] field, then
            1. Let _pattern12_ be the string _connector_ with the substring *"{0}"* replaced with _timeFormat_.[[pattern12]] and the substring *"{1}"* replaced with _dateFormat_.[[pattern]].
            1. Set _format_.[[pattern12]] to _pattern12_.
          1. Let _dateTimeRangeFormat_ be _styles_.[[DateTimeRangeFormat]].[[&lt;_dateStyle_&gt;]].[[&lt;_timeStyle_&gt;]].
          1. Set _format_.[[rangePatterns]] to _dateTimeRangeFormat_.[[rangePatterns]].
          1. If _dateTimeRangeFormat_ has a [[rangePatterns12]] field, then
            1. Set _format_.[[rangePatterns12]] to _dateTimeRangeFormat_.[[rangePatterns12]].
          1. Return _format_.
        1. If _timeStyle_ is not *undefined*, then
          1. Return _timeFormat_.
        1. Assert: _dateStyle_ is not *undefined*.
        1. Return _dateFormat_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-basicformatmatcher" type="abstract operation">
      <h1>
        BasicFormatMatcher (
          _options_: a Record,
          _formats_: a List of Records,
        ): a Record
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _removalPenalty_ be 120.
        1. Let _additionPenalty_ be 20.
        1. Let _longLessPenalty_ be 8.
        1. Let _longMorePenalty_ be 6.
        1. Let _shortLessPenalty_ be 6.
        1. Let _shortMorePenalty_ be 3.
        1. Let _offsetPenalty_ be 1.
        1. Let _bestScore_ be -∞.
        1. Let _bestFormat_ be *undefined*.
        1. Assert: Type(_formats_) is List.
        1. For each element _format_ of _formats_, do
          1. Let _score_ be 0.
          1. For each property name _property_ shown in <emu-xref href="#table-datetimeformat-components"></emu-xref>, do
            1. If _options_ has a field [[&lt;_property_&gt;]], let _optionsProp_ be _options_.[[&lt;_property_&gt;]]; else let _optionsProp_ be *undefined*.
            1. If _format_ has a field [[&lt;_property_&gt;]], let _formatProp_ be _format_.[[&lt;_property_&gt;]]; else let _formatProp_ be *undefined*.
            1. If _optionsProp_ is *undefined* and _formatProp_ is not *undefined*, then
              1. Set _score_ to _score_ - _additionPenalty_.
            1. Else if _optionsProp_ is not *undefined* and _formatProp_ is *undefined*, then
              1. Set _score_ to _score_ - _removalPenalty_.
            1. Else if _property_ is *"timeZoneName"*, then
              1. If _optionsProp_ is *"short"* or *"shortGeneric"*, then
                1. If _formatProp_ is *"shortOffset"*, set _score_ to _score_ - _offsetPenalty_.
                1. Else if _formatProp_ is *"longOffset"*, set _score_ to _score_ - (_offsetPenalty_ + _shortMorePenalty_).
                1. Else if _optionsProp_ is *"short"* and _formatProp_ is *"long"*, set _score_ to _score_ - _shortMorePenalty_.
                1. Else if _optionsProp_ is *"shortGeneric"* and _formatProp_ is *"longGeneric"*, set _score_ to _score - _shortMorePenalty_.
                1. Else if _optionsProp_ &ne; _formatProp_, set _score_ to _score_ - _removalPenalty_.
              1. Else if _optionsProp_ is *"shortOffset"* and _formatProp_ is *"longOffset"*, then
                1. Set _score_ to _score_ - _shortMorePenalty_.
              1. Else if _optionsProp_ is *"long"* or *"longGeneric"*, then
                1. If _formatProp_ is *"longOffset"*, set _score_ to _score_ - _offsetPenalty_.
                1. Else if _formatProp_ is *"shortOffset"*, set _score_ to _score_ - (_offsetPenalty_ + _longLessPenalty_).
                1. Else if _optionsProp_ is *"long"* and _formatProp_ is *"short"*, set _score_ to _score_ - _longLessPenalty_.
                1. Else if _optionsProp_ is *"longGeneric"* and _formatProp_ is *"shortGeneric"*, set _score_ to _score_ - _longLessPenalty_.
                1. Else if _optionsProp_ &ne; _formatProp_, set _score_ to _score_ - _removalPenalty_.
              1. Else if _optionsProp_ is *"longOffset"* and _formatProp_ is *"shortOffset"*, then
                1. Set _score_ to _score_ - _longLessPenalty_.
              1. Else if _optionsProp_ &ne; _formatProp_, then
                1. Set _score_ to _score_ - _removalPenalty_.
            1. Else if _optionsProp_ &ne; _formatProp_, then
              1. If _property_ is *"fractionalSecondDigits"*, then
                1. Let _values_ be &laquo; 1, 2, 3 &raquo;.
              1. Else,
                1. Let _values_ be &laquo; *"2-digit"*, *"numeric"*, *"narrow"*, *"short"*, *"long"* &raquo;.
              1. Let _optionsPropIndex_ be the index of _optionsProp_ within _values_.
              1. Let _formatPropIndex_ be the index of _formatProp_ within _values_.
              1. Let _delta_ be max(min(_formatPropIndex_ - _optionsPropIndex_, 2), -2).
              1. If _delta_ = 2, set _score_ to _score_ - _longMorePenalty_.
              1. Else if _delta_ = 1, set _score_ to _score_ - _shortMorePenalty_.
              1. Else if _delta_ = -1, set _score_ to _score_ - _shortLessPenalty_.
              1. Else if _delta_ = -2, set _score_ to _score_ - _longLessPenalty_.
          1. If _score_ > _bestScore_, then
            1. Set _bestScore_ to _score_.
            1. Set _bestFormat_ to _format_.
        1. Return _bestFormat_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-bestfitformatmatcher" type="implementation-defined abstract operation">
      <h1>
        BestFitFormatMatcher (
          _options_: a Record,
          _formats_: a List of Records,
        ): a Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns a set of component representations that a typical user of the selected locale would perceive as at least as good as the one returned by BasicFormatMatcher.</dd>
      </dl>
    </emu-clause>

    <emu-clause id="sec-datetime-format-functions">
      <h1>DateTime Format Functions</h1>

      <p>A DateTime format function is an anonymous built-in function that has a [[DateTimeFormat]] internal slot.</p>
      <p>When a DateTime format function _F_ is called with optional argument _date_, the following steps are taken:</p>

      <emu-alg>
        1. Let _dtf_ be _F_.[[DateTimeFormat]].
        1. Assert: Type(_dtf_) is Object and _dtf_ has an [[InitializedDateTimeFormat]] internal slot.
        1. If _date_ is not provided or is *undefined*, then
          1. Let _x_ be ! Call(%Date.now%, *undefined*).
        1. Else,
          1. Let _x_ be ? ToNumber(_date_).
        1. Return ? FormatDateTime(_dtf_, _x_).
      </emu-alg>

      <p>
        The *"length"* property of a DateTime format function is *1*<sub>𝔽</sub>.
      </p>
    </emu-clause>

    <emu-clause id="sec-formatdatetimepattern" type="abstract operation">
      <h1>
        FormatDateTimePattern (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _patternParts_: a List of Records as returned by PartitionPattern,
          _x_: a Number,
          _rangeFormatOptions_: a range pattern Record as used in [[rangePattern]], or *undefined*,
        ): either a normal completion containing a List of Records with fields [[Type]] (a String) and [[Value]] (a String), or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It interprets _x_ as a time value as specified in es2024, <emu-xref href="#sec-time-values-and-time-range"></emu-xref>, and creates the corresponding parts according _pattern_ and to the effective locale and the formatting options of _dateTimeFormat_ and _rangeFormatOptions_.</dd>
      </dl>
      <emu-alg>
        1. Let _x_ be TimeClip(_x_).
        1. If _x_ is *NaN*, throw a *RangeError* exception.
        1. Let _locale_ be _dateTimeFormat_.[[Locale]].
        1. Let _nfOptions_ be OrdinaryObjectCreate(*null*).
        1. Perform ! CreateDataPropertyOrThrow(_nfOptions_, *"useGrouping"*, *false*).
        1. Let _nf_ be ! Construct(%NumberFormat%, &laquo; _locale_, _nfOptions_ &raquo;).
        1. Let _nf2Options_ be OrdinaryObjectCreate(*null*).
        1. Perform ! CreateDataPropertyOrThrow(_nf2Options_, *"minimumIntegerDigits"*, *2*<sub>𝔽</sub>).
        1. Perform ! CreateDataPropertyOrThrow(_nf2Options_, *"useGrouping"*, *false*).
        1. Let _nf2_ be ! Construct(%NumberFormat%, &laquo; _locale_, _nf2Options_ &raquo;).
        1. Let _fractionalSecondDigits_ be _dateTimeFormat_.[[FractionalSecondDigits]].
        1. If _fractionalSecondDigits_ is not *undefined*, then
          1. Let _nf3Options_ be OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_nf3Options_, *"minimumIntegerDigits"*, 𝔽(_fractionalSecondDigits_)).
          1. Perform ! CreateDataPropertyOrThrow(_nf3Options_, *"useGrouping"*, *false*).
          1. Let _nf3_ be ! Construct(%NumberFormat%, &laquo; _locale_, _nf3Options_ &raquo;).
        1. Let _tm_ be ToLocalTime(ℤ(ℝ(_x_) &times; 10<sup>6</sup>), _dateTimeFormat_.[[Calendar]], _dateTimeFormat_.[[TimeZone]]).
        1. Let _result_ be a new empty List.
        1. For each Record { [[Type]], [[Value]] } _patternPart_ in _patternParts_, do
          1. Let _p_ be _patternPart_.[[Type]].
          1. If _p_ is *"literal"*, then
            1. Append a new Record { [[Type]]: *"literal"*, [[Value]]: _patternPart_.[[Value]] } as the last element of the list _result_.
          1. Else if _p_ is equal to *"fractionalSecondDigits"*, then
            1. Assert: _fractionalSecondDigits_ is not *undefined*.
            1. Let _v_ be _tm_.[[Millisecond]].
            1. Set _v_ to floor(_v_ &times; 10<sup>( _fractionalSecondDigits_ - 3 )</sup>).
            1. Let _fv_ be FormatNumeric(_nf3_, _v_).
            1. Append a new Record { [[Type]]: *"fractionalSecond"*, [[Value]]: _fv_ } as the last element of _result_.
          1. Else if _p_ is equal to *"dayPeriod"*, then
            1. Let _f_ be _dateTimeFormat_.[[DayPeriod]].
            1. Let _fv_ be a String value representing the day period of _tm_ in the form given by _f_; the String value depends upon the implementation and the effective locale of _dateTimeFormat_.
            1. Append a new Record { [[Type]]: _p_, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ is equal to *"timeZoneName"*, then
            1. Let _f_ be _dateTimeFormat_.[[TimeZoneName]].
            1. Let _v_ be _dateTimeFormat_.[[TimeZone]].
            1. Let _fv_ be a String value representing _v_ in the form given by _f_; the String value depends upon the implementation and the effective locale of _dateTimeFormat_. The String value may also depend on the value of the [[InDST]] field of _tm_ if _f_ is *"short"*, *"long"*, *"shortOffset"*, or *"longOffset"*. If the implementation does not have such a localized representation of _v_, then use the String value of _v_ itself.
            1. Append a new Record { [[Type]]: _p_, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ matches a Property column of the row in <emu-xref href="#table-datetimeformat-components"></emu-xref>, then
            1. If _rangeFormatOptions_ is not *undefined*, let _f_ be the value of _rangeFormatOptions_'s field whose name matches _p_.
            1. Else, let _f_ be the value of _dateTimeFormat_'s internal slot whose name is the Internal Slot column of the matching row.
            1. Let _v_ be the value of _tm_'s field whose name is the Internal Slot column of the matching row.
            1. If _p_ is *"year"* and _v_ &le; 0, set _v_ to 1 - _v_.
            1. If _p_ is *"month"*, set _v_ to _v_ + 1.
            1. If _p_ is *"hour"* and _dateTimeFormat_.[[HourCycle]] is *"h11"* or *"h12"*, then
              1. Set _v_ to _v_ modulo 12.
              1. If _v_ is 0 and _dateTimeFormat_.[[HourCycle]] is *"h12"*, set _v_ to 12.
            1. If _p_ is *"hour"* and _dateTimeFormat_.[[HourCycle]] is *"h24"*, then
              1. If _v_ is 0, set _v_ to 24.
            1. If _f_ is *"numeric"*, then
              1. Let _fv_ be FormatNumeric(_nf_, _v_).
            1. Else if _f_ is *"2-digit"*, then
              1. Let _fv_ be FormatNumeric(_nf2_, _v_).
              1. If the *"length"* property of _fv_ is greater than 2, set _fv_ to the substring of _fv_ containing the last two characters.
            1. Else if _f_ is *"narrow"*, *"short"*, or *"long"*, then
              1. Let _fv_ be a String value representing _v_ in the form given by _f_; the String value depends upon the implementation and the effective locale and calendar of _dateTimeFormat_. If _p_ is *"month"* and _rangeFormatOptions_ is *undefined*, then the String value may also depend on whether _dateTimeFormat_.[[Day]] is *undefined*. If _p_ is *"month"* and _rangeFormatOptions_ is not *undefined*, then the String value may also depend on whether _rangeFormatOptions_.[[day]] is *undefined*. If _p_ is *"era"* and _rangeFormatOptions_ is *undefined*, then the String value may also depend on whether _dateTimeFormat_.[[Era]] is *undefined*. If _p_ is *"era"* and _rangeFormatOptions_ is not *undefined*, then the String value may also depend on whether _rangeFormatOptions_.[[era]] is *undefined*. If the implementation does not have such a localized representation of _v_, then use ! ToString(_v_).
            1. Append a new Record { [[Type]]: _p_, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ is equal to *"ampm"*, then
            1. Let _v_ be _tm_.[[Hour]].
            1. If _v_ is greater than 11, then
              1. Let _fv_ be an implementation and locale dependent String value representing *"post meridiem"*.
            1. Else,
              1. Let _fv_ be an implementation and locale dependent String value representing *"ante meridiem"*.
            1. Append a new Record { [[Type]]: *"dayPeriod"*, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ is equal to *"relatedYear"*, then
            1. Let _v_ be _tm_.[[RelatedYear]].
            1. Let _fv_ be FormatNumeric(_nf_, _v_).
            1. Append a new Record { [[Type]]: *"relatedYear"*, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else if _p_ is equal to *"yearName"*, then
            1. Let _v_ be _tm_.[[YearName]].
            1. Let _fv_ be an implementation and locale dependent String value representing _v_.
            1. Append a new Record { [[Type]]: *"yearName"*, [[Value]]: _fv_ } as the last element of the list _result_.
          1. Else,
            1. Let _unknown_ be an implementation-, locale-, and numbering system-dependent String based on _x_ and _p_.
            1. Append a new Record { [[Type]]: *"unknown"*, [[Value]]: _unknown_ } as the last element of _result_.
        1. Return _result_.
      </emu-alg>

      <emu-note>
        It is recommended that implementations use the locale and calendar dependent strings provided by the Common Locale Data Repository (available at <a href="https://cldr.unicode.org/">https://cldr.unicode.org/</a>), and use CLDR *"abbreviated"* strings for DateTimeFormat *"short"* strings, and CLDR *"wide"* strings for DateTimeFormat *"long"* strings.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-partitiondatetimepattern" type="abstract operation">
      <h1>
        PartitionDateTimePattern (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number,
        ): either a normal completion containing a List of Records with fields [[Type]] (a String) and [[Value]] (a String), or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It interprets _x_ as a time value as specified in es2024, <emu-xref href="#sec-time-values-and-time-range"></emu-xref>, and creates the corresponding parts according to the effective locale and the formatting options of _dateTimeFormat_.</dd>
      </dl>
      <emu-alg>
        1. Let _patternParts_ be PartitionPattern(_dateTimeFormat_.[[Pattern]]).
        1. Let _result_ be ? FormatDateTimePattern(_dateTimeFormat_, _patternParts_, _x_, *undefined*).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatdatetime" type="abstract operation">
      <h1>
        FormatDateTime (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number,
        ): either a normal completion containing a String or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimePattern(_dateTimeFormat_, _x_).
        1. Let _result_ be the empty String.
        1. For each Record { [[Type]], [[Value]] } _part_ in _parts_, do
          1. Set _result_ to the string-concatenation of _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatdatetimetoparts" type="abstract operation">
      <h1>
        FormatDateTimeToParts (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number,
        ): either a normal completion containing an Array or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimePattern(_dateTimeFormat_, _x_).
        1. Let _result_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. For each Record { [[Type]], [[Value]] } _part_ in _parts_, do
          1. Let _O_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"type"*, _part_.[[Type]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"value"*, _part_.[[Value]]).
          1. Perform ! CreateDataPropertyOrThrow(_result_, ! ToString(𝔽(_n_)), _O_).
          1. Increment _n_ by 1.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-partitiondatetimerangepattern" type="abstract operation">
      <h1>
        PartitionDateTimeRangePattern (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number,
          _y_: a Number,
        ): either a normal completion containing a List of Records with fields [[Type]] (a String), [[Value]] (a String), and [[Source]] (a String), or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It interprets _x_ and _y_ as time values as specified in es2024, <emu-xref href="#sec-time-values-and-time-range"></emu-xref>, and creates the corresponding parts according to the effective locale and the formatting options of _dateTimeFormat_.</dd>
      </dl>
      <emu-alg>
        1. Set _x_ to TimeClip(_x_).
        1. If _x_ is *NaN*, throw a *RangeError* exception.
        1. Set _y_ to TimeClip(_y_).
        1. If _y_ is *NaN*, throw a *RangeError* exception.
        1. Let _tm1_ be ToLocalTime(ℤ(ℝ(_x_) &times; 10<sup>6</sup>), _dateTimeFormat_.[[Calendar]], _dateTimeFormat_.[[TimeZone]]).
        1. Let _tm2_ be ToLocalTime(ℤ(ℝ(_y_) &times; 10<sup>6</sup>), _dateTimeFormat_.[[Calendar]], _dateTimeFormat_.[[TimeZone]]).
        1. Let _rangePatterns_ be _dateTimeFormat_.[[RangePatterns]].
        1. Let _selectedRangePattern_ be *undefined*.
        1. Let _relevantFieldsEqual_ be *true*.
        1. Let _checkMoreFields_ be *true*.
        1. For each row of <emu-xref href="#table-datetimeformat-rangepatternfields"></emu-xref>, except the header row, in table order, do
          1. Let _fieldName_ be the name given in the Range Pattern Field column of the row.
          1. If _rangePatterns_ has a field [[&lt;_fieldName_&gt;]], let _rangePattern_ be _rangePatterns_.[[&lt;_fieldName_&gt;]]; else let _rangePattern_ be *undefined*.
          1. If _selectedRangePattern_ is not *undefined* and _rangePattern_ is *undefined*, then
            1. NOTE: Because there is no range pattern for differences at or below this field, no further checks will be performed.
            1. Set _checkMoreFields_ to *false*.
          1. If _relevantFieldsEqual_ is *true* and _checkMoreFields_ is *true*, then
            1. Set _selectedRangePattern_ to _rangePattern_.
            1. If _fieldName_ is equal to [[AmPm]], then
              1. If _tm1_.[[Hour]] is less than 12, let _v1_ be *"am"*; else let _v1_ be *"pm"*.
              1. If _tm2_.[[Hour]] is less than 12, let _v2_ be *"am"*; else let _v2_ be *"pm"*.
            1. Else if _fieldName_ is equal to [[DayPeriod]], then
              1. Let _v1_ be a String value representing the day period of _tm1_; the String value depends upon the implementation and the effective locale of _dateTimeFormat_.
              1. Let _v2_ be a String value representing the day period of _tm2_; the String value depends upon the implementation and the effective locale of _dateTimeFormat_.
            1. Else if _fieldName_ is equal to [[FractionalSecondDigits]], then
              1. Let _fractionalSecondDigits_ be _dateTimeFormat_.[[FractionalSecondDigits]].
              1. If _fractionalSecondDigits_ is *undefined*, then
                1. Set _fractionalSecondDigits_ to 3.
              1. Let _exp_ be _fractionalSecondDigits_ - 3.
              1. Let _v1_ be floor(_tm1_.[[Millisecond]] &times; 10<sup>_exp_</sup>).
              1. Let _v2_ be floor(_tm2_.[[Millisecond]] &times; 10<sup>_exp_</sup>).
            1. Else,
              1. Let _v1_ be _tm1_.[[&lt;_fieldName_&gt;]].
              1. Let _v2_ be _tm2_.[[&lt;_fieldName_&gt;]].
            1. If _v1_ is not equal to _v2_, then
              1. Set _relevantFieldsEqual_ to *false*.
        1. If _relevantFieldsEqual_ is *true*, then
          1. Let _collapsedResult_ be a new empty List.
          1. Let _pattern_ be _dateTimeFormat_.[[Pattern]].
          1. Let _patternParts_ be PartitionPattern(_pattern_).
          1. Let _resultParts_ be ! FormatDateTimePattern(_dateTimeFormat_, _patternParts_, _x_, *undefined*).
          1. For each Record { [[Type]], [[Value]] } _r_ in _resultParts_, do
            1. Append a new Record { [[Type]]: _r_.[[Type]], [[Value]]: _r_.[[Value]], [[Source]]: *"shared"* } as the last element of _collapsedResult_.
          1. Return _collapsedResult_.
        1. Let _rangeResult_ be a new empty List.
        1. If _selectedRangePattern_ is *undefined*, then
          1. Set _selectedRangePattern_ to _rangePatterns_.[[Default]].
        1. For each Record { [[Pattern]], [[Source]] } _rangePatternPart_ in _selectedRangePattern_.[[PatternParts]], do
          1. Let _pattern_ be _rangePatternPart_.[[Pattern]].
          1. Let _source_ be _rangePatternPart_.[[Source]].
          1. If _source_ is *"startRange"* or *"shared"*, then
            1. Let _z_ be _x_.
          1. Else,
            1. Let _z_ be _y_.
          1. Let _patternParts_ be PartitionPattern(_pattern_).
          1. Let _resultParts_ be ! FormatDateTimePattern(_dateTimeFormat_, _patternParts_, _z_, _selectedRangePattern_).
          1. For each Record { [[Type]], [[Value]] } _r_ in _resultParts_, do
            1. Append a new Record { [[Type]]: _r_.[[Type]], [[Value]]: _r_.[[Value]], [[Source]]: _source_ } as the last element of _rangeResult_.
        1. Return _rangeResult_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatdatetimerange" type="abstract operation">
      <h1>
        FormatDateTimeRange (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number,
          _y_: a Number,
        ): either a normal completion containing a String or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimeRangePattern(_dateTimeFormat_, _x_, _y_).
        1. Let _result_ be the empty String.
        1. For each Record { [[Type]], [[Value]], [[Source]] } _part_ in _parts_, do
          1. Set _result_ to the string-concatenation of _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-formatdatetimerangetoparts" type="abstract operation">
      <h1>
        FormatDateTimeRangeToParts (
          _dateTimeFormat_: an Intl.DateTimeFormat,
          _x_: a Number,
          _y_: a Number,
        ): either a normal completion containing an Array or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _parts_ be ? PartitionDateTimeRangePattern(_dateTimeFormat_, _x_, _y_).
        1. Let _result_ be ! ArrayCreate(0).
        1. Let _n_ be 0.
        1. For each Record { [[Type]], [[Value]], [[Source]] } _part_ in _parts_, do
          1. Let _O_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"type"*, _part_.[[Type]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"value"*, _part_.[[Value]]).
          1. Perform ! CreateDataPropertyOrThrow(_O_, *"source"*, _part_.[[Source]]).
          1. Perform ! CreateDataPropertyOrThrow(_result_, ! ToString(𝔽(_n_)), _O_).
          1. Increment _n_ by 1.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tolocaltime" type="implementation-defined abstract operation">
      <h1>
        ToLocalTime (
          _epochNs_: a BigInt,
          _calendar_: a String,
          _timeZoneIdentifier_: a String,
        ): a ToLocalTime Record
      </h1>

      <dl class="header">
        <dt>description</dt>
        <dd></dd>
      </dl>

      <emu-alg>
        1. If IsTimeZoneOffsetString(_timeZoneIdentifier_) is *true*, then
          1. Let _offsetNs_ be ParseTimeZoneOffsetString(_timeZoneIdentifier_).
        1. Else,
          1. Assert: IsValidTimeZoneName(_timeZoneIdentifier_) is *true*.
          1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_timeZoneIdentifier_, _epochNs_).
        1. Let _tz_ be ℝ(_epochNs_) + _offsetNs_.
        1. If _calendar_ is *"gregory"*, then
          1. Return a ToLocalTime Record with fields calculated from _tz_ according to <emu-xref href="#table-datetimeformat-tolocaltime-record"></emu-xref>.
        1. Else,
          1. Return a ToLocalTime Record with the fields calculated from _tz_ for the given _calendar_. The calculations should use best available information about the specified _calendar_.
      </emu-alg>

      <emu-note>
        A conforming implementation must recognize *"UTC"* and all Zone and Link names from the IANA Time Zone Database (and <strong>only</strong> such names), and use best available current and historical information about their offsets from UTC and their daylight saving time rules in calculations.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-datetimeformat-tolocaltime-records">
      <h1>ToLocalTime Records</h1>

      <p>
        Each <dfn id="datetimeformat-tolocaltime-record">ToLocalTime Record</dfn> has the fields defined in <emu-xref href="#table-datetimeformat-tolocaltime-record"></emu-xref>.
      </p>

      <emu-table id="table-datetimeformat-tolocaltime-record">
        <emu-caption>Record returned by ToLocalTime</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Field Name</th>
              <th>Value Type</th>
              <th>Value Calculation for Gregorian Calendar</th>
            </tr>
          </thead>
          <tr>
            <td>[[Weekday]]</td>
            <td>an integer</td>
            <td>ℝ(WeekDay(𝔽(floor(_tz_ / 10<sup>6</sup>))))</td>
          </tr>
          <tr>
            <td>[[Era]]</td>
            <td>a String</td>
            <td>Let _year_ be YearFromTime(𝔽(floor(_tz_ / 10<sup>6</sup>))). If _year_ &lt; *1*<sub>𝔽</sub>, return *"BC"*, else return *"AD"*.</td>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>an integer</td>
            <td>ℝ(YearFromTime(𝔽(floor(_tz_ / 10<sup>6</sup>))))</td>
          </tr>
          <tr>
            <td>[[RelatedYear]]</td>
            <td>an integer or *undefined*</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>[[YearName]]</td>
            <td>a String or *undefined*</td>
            <td>*undefined*</td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>an integer</td>
            <td>ℝ(MonthFromTime(𝔽(floor(_tz_ / 10<sup>6</sup>))))</td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>an integer</td>
            <td>ℝ(DateFromTime(𝔽(floor(_tz_ / 10<sup>6</sup>))))</td>
          </tr>
          <tr>
            <td>[[Hour]]</td>
            <td>an integer</td>
            <td>ℝ(HourFromTime(𝔽(floor(_tz_ / 10<sup>6</sup>))))</td>
          </tr>
          <tr>
            <td>[[Minute]]</td>
            <td>an integer</td>
            <td>ℝ(MinFromTime(𝔽(floor(_tz_ / 10<sup>6</sup>))))</td>
          </tr>
          <tr>
            <td>[[Second]]</td>
            <td>an integer</td>
            <td>ℝ(SecFromTime(𝔽(floor(_tz_ / 10<sup>6</sup>))))</td>
          </tr>
          <tr>
            <td>[[Millisecond]]</td>
            <td>an integer</td>
            <td>ℝ(msFromTime(𝔽(floor(_tz_ / 10<sup>6</sup>))))</td>
          </tr>
          <tr>
            <td>[[InDST]]</td>
            <td>a Boolean</td>
            <td>Calculate *true* or *false* using the best available information about the specified _calendar_ and _timeZoneIdentifier_, including current and historical information from the IANA Time Zone Database about time zone offsets from UTC and daylight saving time rules.</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-normative-optional>
    <emu-clause id="sec-unwrapdatetimeformat" type="abstract operation">
      <h1>
        UnwrapDateTimeFormat (
          _dtf_: an ECMAScript language value,
        ): either a normal completion containing an ECMAScript language value or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns the DateTimeFormat instance of its input object, which is either the value itself or a value associated with it by %DateTimeFormat% according to the normative optional constructor mode of <emu-xref href="#legacy-constructor"></emu-xref>.
        </dd>
      </dl>
      <emu-alg>
        1. If Type(_dtf_) is not Object, throw a *TypeError* exception.
        1. If _dtf_ does not have an [[InitializedDateTimeFormat]] internal slot and ? OrdinaryHasInstance(%DateTimeFormat%, _dtf_) is *true*, then
          1. Return ? Get(_dtf_, %Intl%.[[FallbackSymbol]]).
        1. Return _dtf_.
      </emu-alg>
    </emu-clause>
    </emu-normative-optional>
  </emu-clause>
</emu-clause>
