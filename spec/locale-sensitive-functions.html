<emu-clause id="locale-sensitive-functions">
  <h1>Locale Sensitive Functions of the ECMAScript Language Specification</h1>

  <p>ECMA-262 describes several locale-sensitive functions. An ECMAScript implementation that implements this specification shall implement these functions as described here.</p>

  <emu-note>
    The Collator, NumberFormat, or DateTimeFormat objects created in the algorithms in this clause are only used within these algorithms. They are never directly accessed by ECMAScript code and need not actually exist within an implementation.
  </emu-note>

  <emu-clause id="sup-properties-of-the-string-prototype-object">
    <h1>Properties of the String Prototype Object</h1>

    <emu-clause id="sup-String.prototype.localeCompare">
      <h1>String.prototype.localeCompare ( _that_ [ , _locales_ [ , _options_ ] ] )</h1>

      <p>This definition supersedes the definition provided in ECMA-262, <emu-xref href="#sec-string.prototype.localecompare"></emu-xref>.</p>

      <p>When the `localeCompare` method is called with argument _that_ and optional arguments _locales_, and _options_, the following steps are taken:</p>

      <emu-alg>
        1. Let _O_ be ? RequireObjectCoercible(*this* value).
        1. Let _S_ be ? ToString(_O_).
        1. Let _thatValue_ be ? ToString(_that_).
        1. Let _collator_ be ? Construct(%Intl.Collator%, ¬´ _locales_, _options_ ¬ª).
        1. Return CompareStrings(_collator_, _S_, _thatValue_).
      </emu-alg>

      <p>The *"length"* property of this function is *1*<sub>ùîΩ</sub>.</p>

      <emu-note>
        The `localeCompare` method itself is not directly suitable as an argument to `Array.prototype.sort` because the latter requires a function of two arguments.
      </emu-note>

      <emu-note>
        The `localeCompare` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
      </emu-note>
    </emu-clause>

    <emu-clause id="sup-string.prototype.tolocalelowercase">
      <h1>String.prototype.toLocaleLowerCase ( [ _locales_ ] )</h1>

      <p>This definition supersedes the definition provided in ECMA-262, <emu-xref href="#sec-string.prototype.tolocalelowercase"></emu-xref>.</p>

      <p>This function interprets a String value as a sequence of code points, as described in ECMA-262, <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>. The following steps are taken:</p>

      <emu-alg>
        1. Let _O_ be ? RequireObjectCoercible(*this* value).
        1. Let _S_ be ? ToString(_O_).
        1. Return ? TransformCase(_S_, _locales_, ~lower~).
      </emu-alg>

      <emu-note>
        The `toLocaleLowerCase` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
      </emu-note>

      <emu-clause id="sec-transform-case" type="abstract operation">
        <h1>
          TransformCase (
            _S_: a String,
            _locales_: an ECMAScript language value,
            _targetCase_: ~lower~ or ~upper~,
          )
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It interprets _S_ as a sequence of UTF-16 encoded code points, as described in ECMA-262, <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>, and returns the result of ILD transformation into _targetCase_ as a new String value.</dd>
        </dl>
        <emu-alg>
          1. Let _requestedLocales_ be ? CanonicalizeLocaleList(_locales_).
          1. If _requestedLocales_ is not an empty List, then
            1. Let _requestedLocale_ be _requestedLocales_[0].
          1. Else,
            1. Let _requestedLocale_ be DefaultLocale().
          1. Let _availableLocales_ be an Available Locales List which includes the language tags for which the Unicode Character Database contains language-sensitive case mappings. If the implementation supports additional locale-sensitive case mappings, _availableLocales_ should also include their corresponding language tags.
          1. Let _match_ be LookupMatchingLocaleByPrefix(_availableLocales_, ¬´ _requestedLocale_ ¬ª).
          1. If _match_ is not *undefined*, let _locale_ be _match_.[[locale]]; else let _locale_ be *"und"*.
          1. Let _codePoints_ be StringToCodePoints(_S_).
          1. If _targetCase_ is ~lower~, then
            1. Let _newCodePoints_ be a List whose elements are the result of a lowercase transformation of _codePoints_ according to an implementation-derived algorithm using _locale_ or the Unicode Default Case Conversion algorithm.
          1. Else,
            1. Assert: _targetCase_ is ~upper~.
            1. Let _newCodePoints_ be a List whose elements are the result of an uppercase transformation of _codePoints_ according to an implementation-derived algorithm using _locale_ or the Unicode Default Case Conversion algorithm.
          1. Return CodePointsToString(_newCodePoints_).
        </emu-alg>

        <p>Code point mappings may be derived according to a tailored version of the Default Case Conversion Algorithms of the Unicode Standard. Implementations may use locale-sensitive tailoring defined in the file <a href="https://unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt"><code>SpecialCasing.txt</code></a> of the Unicode Character Database and/or CLDR and/or any other custom tailoring. Regardless of tailoring, a conforming implementation's case transformation algorithm must always yield the same result given the same input code points, locale, and target case.</p>

        <emu-note>
          The case mapping of some code points may produce multiple code points, and therefore the result may not be the same length as the input. Because both `toLocaleUpperCase` and `toLocaleLowerCase` have context-sensitive behaviour, the functions are not symmetrical. In other words, `s.toLocaleUpperCase().toLocaleLowerCase()` is not necessarily equal to `s.toLocaleLowerCase()` and `s.toLocaleLowerCase().toLocaleUpperCase()` is not necessarily equal to `s.toLocaleUpperCase()`.
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sup-string.prototype.tolocaleuppercase">
      <h1>String.prototype.toLocaleUpperCase ( [ _locales_ ] )</h1>

      <p>This definition supersedes the definition provided in ECMA-262, <emu-xref href="#sec-string.prototype.tolocaleuppercase"></emu-xref>.</p>

      <p>This function interprets a String value as a sequence of code points, as described in ECMA-262, <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>. The following steps are taken:</p>

      <emu-alg>
        1. Let _O_ be ? RequireObjectCoercible(*this* value).
        1. Let _S_ be ? ToString(_O_).
        1. Return ? TransformCase(_S_, _locales_, ~upper~).
      </emu-alg>

      <emu-note>
        The `toLocaleUpperCase` function is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sup-properties-of-the-number-prototype-object">
    <h1>Properties of the Number Prototype Object</h1>

    <p>The following definition(s) refer to the abstract operation thisNumberValue as defined in ECMA-262, <emu-xref href="#sec-properties-of-the-number-prototype-object"></emu-xref>.</p>

    <emu-clause id="sup-number.prototype.tolocalestring">
      <h1>Number.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>

      <p>This definition supersedes the definition provided in ECMA-262, <emu-xref href="#sec-number.prototype.tolocalestring"></emu-xref>.</p>

      <p>When the `toLocaleString` method is called with optional arguments _locales_ and _options_, the following steps are taken:</p>

      <emu-alg>
        1. Let _x_ be ? ThisNumberValue(*this* value).
        1. Let _numberFormat_ be ? Construct(%Intl.NumberFormat%, ¬´ _locales_, _options_ ¬ª).
        1. Return FormatNumeric(_numberFormat_, ! ToIntlMathematicalValue(_x_)).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sup-properties-of-the-bigint-prototype-object">
    <h1>Properties of the BigInt Prototype Object</h1>

    <p>The following definition(s) refer to the abstract operation thisBigIntValue as defined in ECMA-262, <emu-xref href="#sec-properties-of-the-bigint-prototype-object"></emu-xref>.</p>

    <emu-clause id="sup-bigint.prototype.tolocalestring">
      <h1>BigInt.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>

      <p>This definition supersedes the definition provided in ECMA-262, <emu-xref href="#sec-bigint.prototype.tolocalestring"></emu-xref>.</p>

      <p>When the `toLocaleString` method is called with optional arguments _locales_ and _options_, the following steps are taken:</p>

      <emu-alg>
        1. Let _x_ be ? ThisBigIntValue(*this* value).
        1. Let _numberFormat_ be ? Construct(%Intl.NumberFormat%, ¬´ _locales_, _options_ ¬ª).
        1. Return FormatNumeric(_numberFormat_, ‚Ñù(_x_)).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sup-properties-of-the-date-prototype-object">
    <h1>Properties of the Date Prototype Object</h1>

    <p>The following definition(s) refer to the abstract operation thisTimeValue as defined in ECMA-262, <emu-xref href="#sec-properties-of-the-date-prototype-object"></emu-xref>.</p>

    <emu-clause id="sup-date.prototype.tolocalestring">
      <h1>Date.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>

      <p>This definition supersedes the definition provided in ECMA-262, <emu-xref href="#sec-date.prototype.tolocalestring"></emu-xref>.</p>

      <p>When the `toLocaleString` method is called with optional arguments _locales_ and _options_, the following steps are taken:</p>

      <emu-alg>
        1. Let _dateObject_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
        1. Let _x_ be _dateObject_.[[DateValue]].
        1. If _x_ is *NaN*, return *"Invalid Date"*.
        1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~any~, ~all~).
        1. Return ! FormatDateTime(_dateFormat_, _x_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-date.prototype.tolocaledatestring">
      <h1>Date.prototype.toLocaleDateString ( [ _locales_ [ , _options_ ] ] )</h1>

      <p>This definition supersedes the definition provided in <emu-xref href="#sec-date.prototype.tolocaledatestring" title></emu-xref>.</p>

      <p>When the `toLocaleDateString` method is called with optional arguments _locales_ and _options_, the following steps are taken:</p>

      <emu-alg>
        1. Let _dateObject_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
        1. Let _x_ be _dateObject_.[[DateValue]].
        1. If _x_ is *NaN*, return *"Invalid Date"*.
        1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~date~, ~date~).
        1. Return ! FormatDateTime(_dateFormat_, _x_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-date.prototype.tolocaletimestring">
      <h1>Date.prototype.toLocaleTimeString ( [ _locales_ [ , _options_ ] ] )</h1>

      <p>This definition supersedes the definition provided in <emu-xref href="#sec-date.prototype.tolocaletimestring" title></emu-xref>.</p>

      <p>When the `toLocaleTimeString` method is called with optional arguments _locales_ and _options_, the following steps are taken:</p>

      <emu-alg>
        1. Let _dateObject_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
        1. Let _x_ be _dateObject_.[[DateValue]].
        1. If _x_ is *NaN*, return *"Invalid Date"*.
        1. Let _timeFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~time~, ~time~).
        1. Return ! FormatDateTime(_timeFormat_, _x_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sup-properties-of-the-array-prototype-object">
    <h1>Properties of the Array Prototype Object</h1>

    <emu-clause id="sup-array.prototype.tolocalestring">
      <h1>Array.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>

      <p>This definition supersedes the definition provided in <emu-xref href="#sec-array.prototype.tolocalestring" title></emu-xref>.</p>

      <p>When the `toLocaleString` method is called with optional arguments _locales_ and _options_, the following steps are taken:</p>

      <emu-alg>
        1. Let _array_ be ? ToObject(*this* value).
        1. Let _len_ be ? LengthOfArrayLike(_array_).
        1. Let _separator_ be the implementation-defined list-separator String value appropriate for the host environment's current locale (such as *", "*).
        1. Let _R_ be the empty String.
        1. Let _k_ be 0.
        1. Repeat, while _k_ &lt; _len_,
          1. If _k_ > 0, then
            1. Set _R_ to the string-concatenation of _R_ and _separator_.
          1. Let _nextElement_ be ? Get(_array_, ! ToString(ùîΩ(_k_))).
          1. If _nextElement_ is not *undefined* or *null*, then
            1. Let _S_ be ? ToString(? Invoke(_nextElement_, *"toLocaleString"*, ¬´ _locales_, _options_ ¬ª)).
            1. Set _R_ to the string-concatenation of _R_ and _S_.
          1. Set _k_ to _k_ + 1.
        1. Return _R_.
      </emu-alg>

      <emu-note>
        This algorithm's steps mirror the steps taken in <emu-xref href="#sec-array.prototype.tolocalestring" title></emu-xref>, with the exception that Invoke(_nextElement_, *"toLocaleString"*) now takes _locales_ and _options_ as arguments.
      </emu-note>

      <emu-note>
        The elements of the array are converted to Strings using their `toLocaleString` methods, and these Strings are then concatenated, separated by occurrences of an implementation-defined locale-sensitive separator String. This function is analogous to `toString` except that it is intended to yield a locale-sensitive result corresponding with conventions of the host environment's current locale.
      </emu-note>

      <emu-note>
        The `toLocaleString` function is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sup-properties-of-the-temporal-duration-prototype-object">
    <h1>Properties of the Temporal.Duration Prototype Object</h1>

    <emu-clause id="sup-temporal.duration.prototype.tolocalestring">
      <h1>Temporal.Duration.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.duration.prototype.tolocalestring" title></emu-xref>.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _duration_ be the *this* value.
        1. Perform ? RequireInternalSlot(_duration_, [[InitializedTemporalDuration]]).
        1. Let _formatter_ be ? Construct(%Intl.DurationFormat%, ¬´ _locales_, _options_ ¬ª).
        1. Let _parts_ be PartitionDurationFormatPattern(_formatter_, _duration_).
        1. Let _result_ be the empty String.
        1. For each Record { [[Type]], [[Value]], [[Unit]] } _part_ in _parts_, do
          1. Set _result_ to the string-concatenation of _result_ and _part_.[[Value]].
        1. Return _result_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sup-properties-of-the-temporal-instant-prototype-object">
    <h1>Properties of the Temporal.Instant Prototype Object</h1>

    <emu-clause id="sup-temporal.instant.prototype.tolocalestring">
      <h1>Temporal.Instant.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.instant.prototype.tolocalestring" title></emu-xref>.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _instant_ be the *this* value.
        1. Perform ? RequireInternalSlot(_instant_, [[InitializedTemporalInstant]]).
        1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~any~, ~all~).
        1. Return ? FormatDateTime(_dateFormat_, _instant_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sup-properties-of-the-temporal-plaindate-prototype-object">
    <h1>Properties of the Temporal.PlainDate Prototype Object</h1>

    <emu-clause id="sup-temporal.plaindate.prototype.tolocalestring">
      <h1>Temporal.PlainDate.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plaindate.prototype.tolocalestring" title></emu-xref>.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _plainDate_ be the *this* value.
        1. Perform ? RequireInternalSlot(_plainDate_, [[InitializedTemporalDate]]).
        1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~date~, ~date~).
        1. Return ? FormatDateTime(_dateFormat_, _plainDate_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sup-properties-of-the-temporal-plaindatetime-prototype-object">
    <h1>Properties of the Temporal.PlainDateTime Prototype Object</h1>

    <emu-clause id="sup-temporal.plaindatetime.prototype.tolocalestring">
      <h1>Temporal.PlainDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plaindatetime.prototype.tolocalestring" title></emu-xref>.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _plainDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_plainDateTime_, [[InitializedTemporalDateTime]]).
        1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~any~, ~all~).
        1. Return ? FormatDateTime(_dateFormat_, _plainDateTime_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sup-properties-of-the-temporal-plainmonthday-prototype-object">
    <h1>Properties of the Temporal.PlainMonthDay Prototype Object</h1>

    <emu-clause id="sup-temporal.plainmonthday.prototype.tolocalestring">
      <h1>Temporal.PlainMonthDay.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plainmonthday.prototype.tolocalestring" title></emu-xref>.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _plainMonthDay_ be the *this* value.
        1. Perform ? RequireInternalSlot(_plainMonthDay_, [[InitializedTemporalMonthDay]]).
        1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~date~, ~date~).
        1. Return ? FormatDateTime(_dateFormat_, _plainMonthDay_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sup-properties-of-the-temporal-plaintime-prototype-object">
    <h1>Properties of the Temporal.PlainTime Prototype Object</h1>

    <emu-clause id="sup-temporal.plaintime.prototype.tolocalestring">
      <h1>Temporal.PlainTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plaintime.prototype.tolocalestring" title></emu-xref>.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _plainTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_plainTime_, [[InitializedTemporalTime]]).
        1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~time~, ~time~).
        1. Return ? FormatDateTime(_dateFormat_, _plainTime_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sup-properties-of-the-temporal-plainyearmonth-prototype-object">
    <h1>Properties of the Temporal.PlainYearMonth Prototype Object</h1>

    <emu-clause id="sup-temporal.plainyearmonth.prototype.tolocalestring">
      <h1>Temporal.PlainYearMonth.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.plainyearmonth.prototype.tolocalestring" title></emu-xref>.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _plainYearMonth_ be the *this* value.
        1. Perform ? RequireInternalSlot(_plainYearMonth_, [[InitializedTemporalYearMonth]]).
        1. Let _dateFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~date~, ~date~).
        1. Return ? FormatDateTime(_dateFormat_, _plainYearMonth_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sup-properties-of-the-temporal-zoneddatetime-prototype-object">
    <h1>Properties of the Temporal.ZonedDateTime Prototype Object</h1>

    <emu-clause id="sup-temporal.zoneddatetime.prototype.tolocalestring">
      <h1>Temporal.ZonedDateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal.zoneddatetime.prototype.tolocalestring" title></emu-xref>.</p>
      <p>This method performs the following steps when called:</p>
      <emu-alg>
        1. Let _zonedDateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_zonedDateTime_, [[InitializedTemporalZonedDateTime]]).
        1. Let _dateTimeFormat_ be ? CreateDateTimeFormat(%Intl.DateTimeFormat%, _locales_, _options_, ~any~, ~all~, _zonedDateTime_.[[TimeZone]]).
        1. If _zonedDateTime_.[[Calendar]] is not *"iso8601"* and CalendarEquals(_zonedDateTime_.[[Calendar]], _dateTimeFormat_.[[Calendar]]) is *false*, throw a *RangeError* exception.
        1. Let _instant_ be ! CreateTemporalInstant(_zonedDateTime_.[[EpochNanoseconds]]).
        1. Return ? FormatDateTime(_dateTimeFormat_, _instant_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-calendar-abstract-ops">
    <h1>Abstract Operations for Calendar Calculations</h1>

    <emu-clause id="sec-calendarsupportsera" type="abstract operation">
      <h1>
        CalendarSupportsEra (
          _calendar_: a calendar type,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The following algorithm refers (via <emu-xref href="#table-eras"></emu-xref>) to the era data from <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">Unicode Technical Standard #35 Part 4 Dates, Calendar Data</a>.
        </dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is listed in the "Calendar" column of <emu-xref href="#table-eras"></emu-xref>, return *true*.
        1. Assert: _calendar_ is listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>.
        1. Return *false*.
      </emu-alg>
      <p>
        <emu-xref href="#table-eras"></emu-xref> lists all currently known eras for the current set of calendars, including their aliases, ranges, and kinds.
        The canonical source for this table is the data described in <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">Unicode Technical Standard #35 Part 4 Dates, Calendar Data</a>.
      </p>
      <p>
        The era kind is used by <emu-xref href="#sec-calendardatearithmeticyearforerayear">CalendarDateArithmeticYearForEraYear</emu-xref> to calculate the arithmetic year ([[Year]]):
        An *Era Kind* ~epoch~ means that the era is the epoch era, so 1 Era has an arithmetic year of 1. An *Era Kind* ~negative~ means
        that the era is a "negative" era growing
        from the epoch, so 1 Era is an arithmetic year of 0, and larger [[EraYear]] values produce smaller, negative arithmetic years. An *Era Kind* of
        ~offset~ means that the era is "offset" by a given number (in the *Offset* column), so 1 Era has an arithmetic year of *Offset*.
      </p>
      <emu-table id="table-eras">
        <emu-caption>Eras</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Calendar</th>
              <th>Era</th>
              <th>Aliases</th>
              <th>Minimum eraYear</th>
              <th>Maximum eraYear</th>
              <th>Era Kind</th>
              <th>Offset</th>
            </tr>
          </thead>
          <tr>
            <td>*"buddhist"*</td>
            <td>*"be"*</td>
            <td></td>
            <td>-‚àû</td>
            <td>+‚àû</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"coptic"*</td>
            <td>*"am"*</td>
            <td></td>
            <td>-‚àû</td>
            <td>+‚àû</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"ethioaa"*</td>
            <td>*"aa"*</td>
            <td></td>
            <td>-‚àû</td>
            <td>+‚àû</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>*"am"*</td>
            <td></td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>*"aa"*</td>
            <td></td>
            <td>-‚àû</td>
            <td>5500</td>
            <td> ~offset~</td>
            <td>-5499</td>
          </tr>
          <tr>
            <td>*"gregory"*</td>
            <td>*"ce"*</td>
            <td>*"ad"*</td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"gregory"*</td>
            <td>*"bce"*</td>
            <td>*"bc"*</td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~negative~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"hebrew"*</td>
            <td>*"am"*</td>
            <td></td>
            <td>-‚àû</td>
            <td>+‚àû</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"indian"*</td>
            <td>*"shaka"*</td>
            <td></td>
            <td>-‚àû</td>
            <td>+‚àû</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"islamic-civil"*</td>
            <td>*"ah"*</td>
            <td></td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"islamic-civil"*</td>
            <td>*"bh"*</td>
            <td></td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~negative~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"islamic-tbla"*</td>
            <td>*"ah"*</td>
            <td></td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"islamic-tbla"*</td>
            <td>*"bh"*</td>
            <td></td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~negative~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"islamic-umalqura"*</td>
            <td>*"ah"*</td>
            <td></td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"islamic-umalqura"*</td>
            <td>*"bh"*</td>
            <td></td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~negative~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"reiwa"*</td>
            <td></td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~offset~</td>
            <td>2019</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"heisei"*</td>
            <td></td>
            <td>1</td>
            <td>31</td>
            <td>~offset~</td>
            <td>1989</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"showa"*</td>
            <td></td>
            <td>1</td>
            <td>64</td>
            <td>~offset~</td>
            <td>1926</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"taisho"*</td>
            <td></td>
            <td>1</td>
            <td>15</td>
            <td>~offset~</td>
            <td>1912</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"meiji"*</td>
            <td></td>
            <td>6</td>
            <td>45</td>
            <td>~offset~</td>
            <td>1868</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"ce"*</td>
            <td>*"ad"*</td>
            <td>1</td>
            <td>1872</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"bce"*</td>
            <td>*"bc"*</td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~negative~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"persian"*</td>
            <td>*"ap"*</td>
            <td></td>
            <td>-‚àû</td>
            <td>+‚àû</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"roc"*</td>
            <td>*"roc"*</td>
            <td></td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"roc"*</td>
            <td>*"broc"*</td>
            <td></td>
            <td>1</td>
            <td>+‚àû</td>
            <td>~negative~</td>
            <td></td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-canonicalizeeraincalendar" type="abstract operation">
      <h1>
        CanonicalizeEraInCalendar (
          _calendar_: a calendar type that is not *"iso8601"*,
          _era_: a String,
        ): a String or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The following algorithm refers to the era data from <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">Unicode Technical Standard #35 Part 4 Dates, Calendar Data</a>.
        </dd>
      </dl>
      <emu-alg>
        1. For each row of <emu-xref href="#table-eras"></emu-xref>, except the header row, do
          1. Let _cal_ be the Calendar value of the current row.
          1. If _cal_ is equal to _calendar_, then
            1. Let _canonicalName_ be the Era value of the current row.
            1. If _canonicalName_ is equal to _era_, return _canonicalName_.
            1. Let _aliases_ be a List whose elements are the strings given in the "Aliases" column of the row.
            1. If _aliases_ contains _era_, return _canonicalName_.
        1. Assert: _calendar_ is listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>.
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-calendarhasmidyeareras" type="abstract operation">
      <h1>
        CalendarHasMidYearEras (
          _calendar_: a calendar type that is not *"iso8601"*,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns *true* if the calendar has eras that start in the middle of the year, or *false* if all eras start on a year boundary.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"japanese"*, return *true*.
        1. Assert: _calendar_ is listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isvalidmonthcodeforcalendar" type="abstract operation">
      <h1>
        IsValidMonthCodeForCalendar (
          _calendar_: a calendar type that is not *"iso8601"*,
          _monthCode_: a month code,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _commonMonthCodes_ be ¬´ *"M01"*, *"M02"*, *"M03"*, *"M04"*, *"M05"*, *"M06"*, *"M07"*, *"M08"*, *"M09"*, *"M10"*, *"M11"*, *"M12"* ¬ª.
        1. If _commonMonthCodes_ contains _monthCode_, return *true*.
        1. If _calendar_ is listed in the "Calendar" column of <emu-xref href="#table-additional-month-codes"></emu-xref>, then
          1. Let _r_ be the row in <emu-xref href="#table-additional-month-codes"></emu-xref> with a value in the Calendar column matching _calendar_.
          1. Let _specialMonthCodes_ be a List whose elements are the strings given in the "Additional Month Codes" column of _r_.
          1. If _specialMonthCodes_ contains _monthCode_, return *true*.
          1. Return *false*.
        1. Assert: _calendar_ is listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>.
        1. Return *false*.
      </emu-alg>

      <emu-table id="table-additional-month-codes">
        <emu-caption>Additional Month Codes in Calendars</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Calendar</th>
              <th>Additional Month Codes</th>
              <th>Leap to Common Month Transformation</th>
            </tr>
          </thead>
          <tr>
            <td>*"chinese"*</td>
            <td>*"M01L"*, *"M02L"*, *"M03L"*, *"M04L"*, *"M05L"*, *"M06L"*, *"M07L"*, *"M08L"*, *"M09L"*, *"M10L"*, *"M11L"*, *"M12L"*</td>
            <td>~skip-backward~</td>
          </tr>
          <tr>
            <td>*"coptic"*</td>
            <td>*"M13"*</td>
            <td></td>
          </tr>
          <tr>
            <td>*"dangi"*</td>
            <td>*"M01L"*, *"M02L"*, *"M03L"*, *"M04L"*, *"M05L"*, *"M06L"*, *"M07L"*, *"M08L"*, *"M09L"*, *"M10L"*, *"M11L"*, *"M12L"*</td>
            <td>~skip-backward~</td>
          </tr>
          <tr>
            <td>*"ethioaa"*</td>
            <td>*"M13"*</td>
            <td></td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>*"M13"*</td>
            <td></td>
          </tr>
          <tr>
            <td>*"hebrew"*</td>
            <td>*"M05L"*</td>
            <td>~skip-forward~</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-yearcontainsmonthcode" type="abstract operation">
      <h1>
        YearContainsMonthCode (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
          _monthCode_: a month code,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns whether the given _monthCode_ exists in _arithmeticYear_ of _calendar_.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: IsValidMonthCodeForCalendar(_calendar_, _monthCode_) is *true*.
        1. If ! ParseMonthCode(_monthCode_).[[IsLeap]] is *false*, return *true*.
        1. Return whether the leap month indicated by _monthCode_ exists in the year _arithmeticYear_ in _calendar_, using calendar-dependent behaviour.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-constrainmonthcode" type="abstract operation">
      <h1>
        ConstrainMonthCode (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
          _monthCode_: a month code,
          _overflow_: ~constrain~ or ~reject~,
        ): either a normal completion containing a month code or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns the month code in _arithmeticYear_ of _calendar_ that best matches the given _monthCode_. If _monthCode_ does not exist in _arithmeticYear_, it is constrained to the best common month if _overflow_ is ~constrain~, or an error is thrown if _overflow_ is ~reject~.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: IsValidMonthCodeForCalendar(_calendar_, _monthCode_) is *true*.
        1. If YearContainsMonthCode(_calendar_, _arithmeticYear_, _monthCode_) is *true*, return _monthCode_.
        1. If _overflow_ is ~reject~, throw a *RangeError* exception.
        1. Assert: _calendar_ is listed in the "Calendar" column of <emu-xref href="#table-additional-month-codes"></emu-xref>.
        1. Let _r_ be the row in <emu-xref href="#table-additional-month-codes"></emu-xref> with a value in the Calendar column matching _calendar_.
        1. Let _shiftType_ be the value given in the "Leap to Common Month Transformation" column of _r_.
        1. If _shiftType_ is ~skip-backward~, then
          1. Return CreateMonthCode(! ParseMonthCode(_monthCode_).[[MonthNumber]], *false*).
        1. Else,
          1. Assert: _monthCode_ is *"M05L"*.
          1. Return *"M06"*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-monthcodetoordinal" type="abstract operation">
      <h1>
        MonthCodeToOrdinal (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
          _monthCode_: a month code,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns the ordinal month number for _monthCode_ in _arithmeticYear_ of _calendar_. The given _monthCode_ must exist in the given year.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: YearContainsMonthCode(_calendar_, _arithmeticYear_, _monthCode_) is *true*.
        1. Let _monthsBefore_ be 0.
        1. Let _number_ be 1.
        1. Let _isLeap_ be *false*.
        1. Let _r_ be the row in <emu-xref href="#table-additional-month-codes"></emu-xref> which the _calendar_ is in the Calendar column.
        1. If the "Leap to Common Month Transformation" column of _r_ is empty, then
          1. Return ! ParseMonthCode(_monthCode_).[[MonthNumber]].
        1. Assert: The "Additional Month Codes" column of _r_ does not contain *"M00L"* or *"M13"*.
        1. Assert: This algorithm will return before the following loop terminates by failing its condition.
        1. Repeat, while _number_ ‚â§ 12,
          1. Let _currentMonthCode_ be CreateMonthCode(_number_, _isLeap_).
          1. If IsValidMonthCodeForCalendar(_calendar_, _currentMonthCode_) is *true* and YearContainsMonthCode(_calendar_, _arithmeticYear_, _currentMonthCode_) is *true*, then
            1. Set _monthsBefore_ to _monthsBefore_ + 1.
          1. If _currentMonthCode_ is _monthCode_, then
            1. Return _monthsBefore_.
          1. If _isLeap_ is *false*, then
            1. Set _isLeap_ to *true*.
          1. Else,
            1. Set _isLeap_ to *false*.
            1. Set _number_ to _number_ + 1.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-calendardaysinmonth" type="abstract operation">
      <h1>
        CalendarDaysInMonth (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
          _ordinalMonth_: a positive integer,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The returned value represents the number of days in the _calendar_-specific _arithmeticYear_ and _ordinalMonth_.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _isoDate_ be ! CalendarIntegersToISO(_calendar_, _arithmeticYear_, _ordinalMonth_, 1).
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[DaysInMonth]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-calendardateera" type="abstract operation">
      <h1>
        CalendarDateEra (
          _calendar_: a calendar type that is not *"iso8601"*,
          _date_: an ISO Date Record,
        ): a String or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns a lowercase String value representing that era, or *undefined* for calendars that do not have eras.</dd>
      </dl>
      <emu-alg>
        1. If CalendarSupportsEra(_calendar_) is *false*, return *undefined*.
        1. Let _era_ be an implementation-defined String indicating the era corresponding to _date_ in the context of the calendar represented by _calendar_.
        1. Return CanonicalizeEraInCalendar(_calendar_, _era_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-calendardateerayear" type="abstract operation">
      <h1>
        CalendarDateEraYear (
          _calendar_: a calendar type that is not *"iso8601"*,
          _date_: an ISO Date Record,
        ): an integer or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the ordinal position of the year of _date_ in that era, or *undefined* for calendars that do not have eras.</dd>
      </dl>
      </dl>
      <emu-alg>
        1. If CalendarSupportsEra(_calendar_) is *false*, return *undefined*.
        1. Return an implementation-defined integer indicating the era year corresponding to _date_ in the context of the calendar represented by _calendar_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-calendardatearithmeticyear" type="abstract operation">
      <h1>
        CalendarDateArithmeticYear (
          _calendar_: a calendar type that is not *"iso8601"*,
          _date_: an ISO Date Record,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the arithmetic year for the date corresponding to _date_ in the context of the calendar represented by _calendar_.</dd>
      </dl>
      <emu-alg>
        1. Assert: _calendar_ is listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>.
        1. Let _r_ be the row in <emu-xref href="#table-epoch-years"></emu-xref> with a value in the Calendar column matching _calendar_.
        1. Let _epochYear_ be the value given in the "Epoch ISO Year" column of _r_.
        1. Let _epochDate_ be the first day of the calendar year starting in ISO year _epochYear_ in the calendar represented by _calendar_, according to implementation-defined processing.
        1. Let _newYear_ be the first day of the calendar year of _date_ in the calendar represented by _calendar_, according to implementation-defined processing.
        1. Let _arithmeticYear_ be the implementation-defined signed number of whole years between _epochDate_ and _newYear_ in the calendar represented by _calendar_.
        1. Return _arithmeticYear_.
      </emu-alg>

      <emu-table id="table-epoch-years">
        <emu-caption>Epoch years</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Calendar</th>
              <th>Epoch ISO Year</th>
            </tr>
          </thead>
          <tr>
            <td>*"buddhist"*</td>
            <td>-543</td>
          </tr>
          <tr>
            <td>*"chinese"*</td>
            <td>0</td>
          </tr>
          <tr>
            <td>*"coptic"*</td>
            <td>283</td>
          </tr>
          <tr>
            <td>*"dangi"*</td>
            <td>0</td>
          </tr>
          <tr>
            <td>*"ethioaa"*</td>
            <td>-5493</td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>7</td>
          </tr>
          <tr>
            <td>*"gregory"*</td>
            <td>0</td>
          </tr>
          <tr>
            <td>*"hebrew"*</td>
            <td>-3761</td>
          </tr>
          <tr>
            <td>*"indian"*</td>
            <td>78</td>
          </tr>
          <tr>
            <td>*"islamic-civil"*</td>
            <td>621</td>
          </tr>
          <tr>
            <td>*"islamic-tbla"*</td>
            <td>621</td>
          </tr>
          <tr>
            <td>*"islamic-umalqura"*</td>
            <td>621</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>0</td>
          </tr>
          <tr>
            <td>*"persian"*</td>
            <td>621</td>
          </tr>
          <tr>
            <td>*"roc"*</td>
            <td>1911</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-calendardatearithmeticyearforerayear" type="abstract operation">
      <h1>
        CalendarDateArithmeticYearForEraYear (
          _calendar_: a calendar type that has eras,
          _era_: a String,
          _eraYear_: an integer,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It produces the arithmetic year for a given set of _era_, _eraYear_ in _calendar_, a calendar that includes an era named _era_.</dd>
      </dl>
      <emu-alg>
        1. Let _era_ be CanonicalizeEraInCalendar(_calendar_, _era_).
        1. Assert: _era_ is not *undefined*.
        1. Assert: _calendar_ is listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>.
        1. Let _r_ be the row in <emu-xref href="#table-eras"></emu-xref> with a value in the Calendar column matching _calendar_ and a value in the Era column matching _era_.
        1. Let _eraKind_ be the value given in the "Era Kind" column of _r_.
        1. Let _offset_ be the value given in the "Offset" column of _r_.
        1. If _eraKind_ is ~epoch~, return _eraYear_.
        1. If _eraKind_ is ~negative~, return <emu-eqn>1 - _eraYear_</emu-eqn>.
        1. Assert: _eraKind_ is ~offset~.
        1. Assert: _offset_ is an integer.
        1. Return <emu-eqn>_offset_ + _eraYear_ - 1</emu-eqn>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-calendarintegerstoiso" type="abstract operation">
      <h1>
        CalendarIntegersToISO (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
          _ordinalMonth_: a positive integer,
          _day_: a positive integer,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns an ISO Date Record that corresponds with the given _calendar_-specific _arithmeticYear_, _ordinalMonth_, and _day_.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. If _arithmeticYear_, _ordinalMonth_, and _day_ do not form a valid date in _calendar_, throw a *RangeError* exception.
        1. Let _isoDate_ be an ISO Date Record such that CalendarISOToDate(_calendar_, _isoDate_) returns a Calendar Date Record whose [[Year]], [[Month]], and [[Day]] field values respectively equal _arithmeticYear_, _ordinalMonth_, and _day_.
        1. NOTE: No known calendars have repeated dates that would cause _isoDate_ to be ambiguous between two ISO Date Records.
        1. Return _isoDate_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-calendar-date-records">
      <h1>Calendar Date Records</h1>
      <p>
        A <dfn variants="Calendar Date Records">Calendar Date Record</dfn> is a Record value used to represent a valid calendar date in a non-ISO 8601 calendar.
        Calendar Date Records are produced by the abstract operation CalendarISOToDate.
      </p>
      <p>Calendar Date Records have the fields listed in <emu-xref href="#table-calendar-date-record-fields"></emu-xref>.</p>
      <p>This definition supersedes the one in <emu-xref href="#sec-calendar-date-records" title></emu-xref>.</p>
      <emu-table id="table-calendar-date-record-fields" caption="Calendar Date Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Era]]</td>
            <td>a String or *undefined*</td>
            <td>
              A lowercase String value representing the date's era, or *undefined* for calendars that do not have eras.<br>
              The value of this field for a calendar type _calendar_ should be the result of calling CalendarDateEra(_calendar_, _date_), where _date_ is the [[ISODate]] field of a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth value corresponding to the date.
            </td>
          </tr>
          <tr>
            <td>[[EraYear]]</td>
            <td>an integer or *undefined*</td>
            <td>
              The ordinal position of the date's year within its era, or *undefined* for calendars that do not have eras.<br>
              The value of this field for a calendar type _calendar_ should be the result of calling CalendarDateEraYear(_calendar_, _date_), where _date_ is the [[ISODate]] field of a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth value corresponding to the date.
              <emu-note>
                Era years are 1-indexed for many calendars, but not all (e.g., the eras of the Burmese calendar, not currently available in CLDR, each start with a year 0). Years can also advance opposite the flow of time (as for BCE years in the Gregorian calendar).
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>an integer</td>
            <td>
              The date's <dfn>arithmetic year</dfn>, which is the year relative to the first day of a calendar-specific <dfn>epoch year</dfn>, given in <emu-xref href="#table-epoch-years"></emu-xref>.<br>
              The value of this field for a calendar type _calendar_ should be the result of calling CalendarDateArithmeticYear(_calendar_, _date_), where _date_ is the [[ISODate]] field of a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth value corresponding to the date.
              <emu-note>The arithmetic year is relative to the first day of the calendar's epoch year, so if the epoch era starts in the middle of the year, the year will be the same value before and after the start date of the era.</emu-note>
            </td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>a positive integer</td>
            <td>
              The 1-based ordinal position of the date's month within its year.
              <emu-note>
                When the number of months in a year of the calendar is variable, a different value can be returned for dates that are part of the same month in different years. For example, in the Hebrew calendar, 1 Nisan 5781 is associated with value 7 while 1 Nisan 5782 is associated with value 8 because 5782 is a leap year and Nisan follows the insertion of Adar I.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[MonthCode]]</td>
            <td>a String</td>
            <td>
              The month code of the date's month. The month code for a month that is not a leap month and whose 1-based ordinal position in a common year of the calendar (i.e., a year that is not a leap year) is _n_ should be the string-concatenation of *"M"* and ToZeroPaddedDecimalString(_n_, 2), and the month code for a month that is a leap month inserted after a month whose 1-based ordinal position in a common year of the calendar is _p_ should be the string-concatenation of *"M"*, ToZeroPaddedDecimalString(_p_, 2), and *"L"*.
              <emu-note>
                For example, in the Hebrew calendar, the month code of Adar (and Adar II, in leap years) is *"M06"* and the month code of Adar I (the leap month inserted before Adar II) is *"M05L"*. Theoretically, in a calendar with a leap month at the start of some years, the month code of that month would be *"M00L"*.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>a positive integer</td>
            <td>
              The 1-based ordinal position of the date's day within its month.
            </td>
          </tr>
          <tr>
            <td>[[DayOfWeek]]</td>
            <td>a positive integer</td>
            <td>
              The day of the week corresponding to the date. The value should be 1-based, where 1 is the day corresponding to Monday in the given calendar.
            </td>
          </tr>
          <tr>
            <td>[[DayOfYear]]</td>
            <td>a positive integer</td>
            <td>
              The 1-based ordinal position of the date's day within its year.
            </td>
          </tr>
          <tr>
            <td>[[WeekOfYear]]</td>
            <td>a Year-Week Record</td>
            <td>
              <p>The date's <em>calendar week of year</em>, and the corresponding <em>week calendar year</em>.</p>
              <p>The Year-Week Record's [[Week]] field should be 1-based.</p>
              <p>The Year-Week Record's [[Year]] field is an arithmetic year as in the Calendar Date Record's [[Year]] field, not relative to an era as in [[EraYear]].</p>
              <p>
                Usually the Year-Week Record's [[Year]] field will contain the same value as the Calendar Date Record's [[Year]] field, but may contain the previous or next year if the week number in the Year-Week Record's [[Week]] field overlaps two different years.
                See also ISOWeekOfYear.
              </p>
              <p>The Year-Week Record contains *undefined* in [[Week]] and [[Year]] field for calendars that do not have a well-defined week numbering system.</p>
              <emu-note>
                Currently, of the calendars supported in this specification, only *"iso8601"* has a well-defined, locale-independent week numbering system.
                For all other calendars, the Year-Week Record fields are *undefined*.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[DaysInWeek]]</td>
            <td>a positive integer</td>
            <td>
              <p>The number of days in the primary notion of week used by the calendar. For all calendars currently supported by this specification, this number is 7.</p>
              <emu-note>
                Some calendars have alternate cyclic notions that are similar to the 7-day week; many of them have multiple (like the Javanese calendar). This specification does not cover such calendars but can be extended to do so in the future.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[DaysInMonth]]</td>
            <td>a positive integer</td>
            <td>The number of days in the date's month.</td>
          </tr>
          <tr>
            <td>[[DaysInYear]]</td>
            <td>a positive integer</td>
            <td>The number of days in the date's year.</td>
          </tr>
          <tr>
            <td>[[MonthsInYear]]</td>
            <td>a positive integer</td>
            <td>The number of months in the date's year.</td>
          </tr>
          <tr>
            <td>[[InLeapYear]]</td>
            <td>a Boolean</td>
            <td>
              *true* if the date falls within a leap year, and *false* otherwise.
              <emu-note>
                A "leap year" is a year that contains more days than other years (for solar or lunar calendars) or more months than other years (for lunisolar calendars like Hebrew or Chinese).
                Some calendars, especially lunisolar ones, have further variation in year length that is not represented in the output of this operation (e.g., the Hebrew calendar includes common years with 353, 354, or 355 days and leap years with 383, 384, or 385 days).
              </emu-note>
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-calendarmonthsinyear" type="abstract operation">
      <h1>
        CalendarMonthsInYear (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The returned value represents the number of months in the _calendar_-specific _arithmeticYear_.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _isoDate_ be ! CalendarIntegersToISO(_calendar_, _arithmeticYear_, 1, 1).
        1. Return CalendarISOToDate(_calendar_, _isoDate_).[[MonthsInYear]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-balancenonisodate" type="abstract operation">
      <h1>
        BalanceNonISODate (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
          _ordinalMonth_: a positive integer,
          _day_: an integer,
        ): a Record with fields [[Year]] (an integer), [[Month]] (a positive integer), and [[Day]] (a positive integer)
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It interprets the given _arithmeticYear_, potentially out-of-range _ordinalMonth_, and potentially out-of-range _day_ as arithmetical values in the given _calendar_ and returns in-range values by overflowing out-of-range _ordinalMonth_ or _day_ values into the next-highest unit.
          This date may correspond to a date in the ISO calendar that is outside the range given by ISODateTimeWithinLimits.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _resolvedYear_ be _arithmeticYear_.
        1. Let _resolvedMonth_ be _ordinalMonth_.
        1. Let _monthsInYear_ be CalendarMonthsInYear(_calendar_, _resolvedYear_).
        1. Repeat, while _resolvedMonth_ ‚â§ 0,
          1. Set _resolvedYear_ to _resolvedYear_ - 1.
          1. Set _monthsInYear_ to CalendarMonthsInYear(_calendar_, _resolvedYear_).
          1. Set _resolvedMonth_ to _resolvedMonth_ + _monthsInYear_.
        1. Repeat, while _resolvedMonth_ > _monthsInYear_,
          1. Set _resolvedMonth_ to _resolvedMonth_ - _monthsInYear_.
          1. Set _resolvedYear_ to _resolvedYear_ + 1.
          1. Set _monthsInYear_ to CalendarMonthsInYear(_calendar_, _resolvedYear_).
        1. Let _resolvedDay_ be _day_.
        1. Let _daysInMonth_ be CalendarDaysInMonth(_calendar_, _resolvedYear_, _resolvedMonth_).
        1. Repeat, while _resolvedDay_ ‚â§ 0,
          1. Set _resolvedMonth_ to _resolvedMonth_ - 1.
          1. If _resolvedMonth_ is 0, then
            1. Set _resolvedYear_ to _resolvedYear_ - 1.
            1. Set _monthsInYear_ to CalendarMonthsInYear(_calendar_, _resolvedYear_).
            1. Set _resolvedMonth_ to _monthsInYear_.
          1. Set _daysInMonth_ to CalendarDaysInMonth(_calendar_, _resolvedYear_, _resolvedMonth_).
          1. Set _resolvedDay_ to _resolvedDay_ + _daysInMonth_.
        1. Repeat, while _resolvedDay_ > _daysInMonth_,
          1. Set _resolvedDay_ to _resolvedDay_ - _daysInMonth_.
          1. Set _resolvedMonth_ to _resolvedMonth_ + 1.
          1. If _resolvedMonth_ > _monthsInYear_, then
            1. Set _resolvedYear_ to _resolvedYear_ + 1.
            1. Set _monthsInYear_ to CalendarMonthsInYear(_calendar_, _resolvedYear_).
            1. Set _resolvedMonth_ to 1.
          1. Set _daysInMonth_ to CalendarDaysInMonth(_calendar_, _resolvedYear_, _resolvedMonth_).
        1. Return the Record { [[Year]]: _resolvedYear_, [[Month]]: _resolvedMonth_, [[Day]]: _resolvedDay_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-nonisodatesurpasses" type="abstract operation">
      <h1>
        NonISODateSurpasses (
          _calendar_: a calendar type that is not *"iso8601"*,
          _sign_: -1 or 1,
          _fromIsoDate_: an ISO Date Record,
          _toIsoDate_: an ISO Date Record,
          _years_: an integer,
          _months_: an integer,
          _weeks_: an integer,
          _days_: an integer,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The return value indicates whether the date _date1_, the result of adding the duration denoted by _years_, _months_, _weeks_, and _days_ to _fromIsoDate_ in the calendar system denoted by _calendar_, surpasses _toIsoDate_ in the direction denoted by _sign_.
          If _weeks_ and _days_ are both zero, then _date1_ need not exist (for example, it could be February 30).
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _parts_ be CalendarISOToDate(_calendar_, _fromIsoDate_).
        1. Let _calDate2_ be CalendarISOToDate(_calendar_, _toIsoDate_).
        1. Let _y0_ be _parts_.[[Year]] + _years_.
        1. If CompareSurpasses(_sign_, _y0_, _parts_.[[MonthCode]], _parts_.[[Day]], _calDate2_) is *true*, return *true*.
        1. Let _m0_ be MonthCodeToOrdinal(_calendar_, _y0_, ! ConstrainMonthCode(_calendar_, _y0_, _parts_.[[MonthCode]], ~constrain~)).
        1. Let _monthsAdded_ be BalanceNonISODate(_calendar_, _y0_, _m0_ + _months_, 1).
        1. If CompareSurpasses(_sign_, _monthsAdded_.[[Year]], _monthsAdded_.[[Month]], _parts_.[[Day]], _calDate2_) is *true*, return *true*.
        1. If _weeks_ = 0 and _days_ = 0, return *false*.
        1. Let _endOfMonth_ be BalanceNonISODate(_calendar_, _monthsAdded_.[[Year]], _monthsAdded_.[[Month]] + 1, 0).
        1. Let _baseDay_ be _parts_.[[Day]].
        1. If _baseDay_ ‚â§ _endOfMonth_.[[Day]], then
          1. Let _regulatedDay_ be _baseDay_.
        1. Else,
          1. Let _regulatedDay_ be _endOfMonth_.[[Day]].
        1. Let _daysInWeek_ be 7 (the number of days in a week for all supported calendars).
        1. Let _balancedDate_ be BalanceNonISODate(_calendar_, _endOfMonth_.[[Year]], _endOfMonth_.[[Month]], _regulatedDay_ + _daysInWeek_ * _weeks_ + _days_).
        1. Return CompareSurpasses(_sign_, _balancedDate_.[[Year]], _balancedDate_.[[Month]], _balancedDate_.[[Day]], _calDate2_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-nonisodateadd" type="abstract operation">
      <h1>
        NonISODateAdd (
          _calendar_: a calendar type that is not *"iso8601"*,
          _isoDate_: an ISO Date Record,
          _duration_: a Date Duration Record,
          _overflow_: ~constrain~ or ~reject~,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The operation performs processing to add _duration_ to _date_ in the context of the calendar represented by _calendar_ and returns the corresponding day, month and year of the result in the ISO 8601 calendar values as an ISO Date Record.
          It may throw a *RangeError* exception if _overflow_ is ~reject~ and the resulting month or day would need to be clamped in order to form a valid date in _calendar_.
        </dd>
      </dl>
      <p>All calendars follow the steps given here, which is a generalization of the precise algorithm specified in CalendarDateAdd for *"iso8601"*.</p>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-nonisodateadd" title></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _parts_ be CalendarISOToDate(_calendar_, _isoDate_).
        1. Let _y0_ be _parts_.[[Year]] + _duration_.[[Years]].
        1. Let _m0_ be MonthCodeToOrdinal(_calendar_, _y0_, ? ConstrainMonthCode(_calendar_, _y0_, _parts_.[[MonthCode]], _overflow_)).
        1. Let _endOfMonth_ be BalanceNonISODate(_calendar_, _y0_, _m0_ + _duration_.[[Months]] + 1, 0).
        1. Let _baseDay_ be _parts_.[[Day]].
        1. If _baseDay_ ‚â§ _endOfMonth_.[[Day]], then
          1. Let _regulatedDay_ be _baseDay_.
        1. Else,
          1. If _overflow_ is ~reject~, throw a *RangeError* exception.
          1. Let _regulatedDay_ be _endOfMonth_.[[Day]].
        1. Let _balancedDate_ be BalanceNonISODate(_calendar_, _endOfMonth_.[[Year]], _endOfMonth_.[[Month]], _regulatedDay_ + 7 * _duration_.[[Weeks]] + _duration_.[[Days]]).
        1. Let _result_ be ? CalendarIntegersToISO(_calendar_, _balancedDate_.[[Year]], _balancedDate_.[[Month]], _balancedDate_.[[Day]]).
        1. If ISODateWithinLimits(_result_) is *false*, throw a *RangeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-nonisodateuntil" type="abstract operation">
      <h1>
        NonISODateUntil (
          _calendar_: a calendar type that is not *"iso8601"*,
          _one_: an ISO Date Record,
          _two_: an ISO Date Record,
          _largestUnit_: a date unit,
        ): a Date Duration Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines the difference between the dates _one_ and _two_ using the years, months, and weeks reckoning of _calendar_.
          No fields larger than _largestUnit_ will be non-zero in the resulting Date Duration Record.
        </dd>
      </dl>
      <p>All calendars follow the steps given here, which is a generalization of the precise algorithm specified in CalendarDateUntil for *"iso8601"*.</p>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-nonisodateuntil" title></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _sign_ be -1 √ó CompareISODate(_one_, _two_).
        1. If _sign_ = 0, return ZeroDateDuration().
        1. Let _years_ be 0.
        1. If _largestUnit_ is ~year~, then
          1. Let _candidateYears_ be _sign_.
          1. Repeat, while NonISODateSurpasses(_calendar_, _sign_, _one_, _two_, _candidateYears_, 0, 0, 0) is *false*,
            1. Set _years_ to _candidateYears_.
            1. Set _candidateYears_ to _candidateYears_ + _sign_.
        1. Let _months_ be 0.
        1. If _largestUnit_ is ~year~ or _largestUnit_ is ~month~, then
          1. Let _candidateMonths_ be _sign_.
          1. Repeat, while NonISODateSurpasses(_calendar_, _sign_, _one_, _two_, _years_, _candidateMonths_, 0, 0) is *false*,
            1. Set _months_ to _candidateMonths_.
            1. Set _candidateMonths_ to _candidateMonths_ + _sign_.
        1. Let _weeks_ be 0.
        1. If _largestUnit_ is ~week~, then
          1. Let _candidateWeeks_ be _sign_.
          1. Repeat, while NonISODateSurpasses(_calendar_, _sign_, _one_, _two_, _years_, _months_, _candidateWeeks_, 0) is *false*,
            1. Set _weeks_ to _candidateWeeks_.
            1. Set _candidateWeeks_ to _candidateWeeks_ + sign.
        1. Let _days_ be 0.
        1. Let _candidateDays_ be _sign_.
        1. Repeat, while NonISODateSurpasses(_calendar_, _sign_, _one_, _two_, _years_, _months_, _weeks_, _candidateDays_) is *false*,
          1. Set _days_ to _candidateDays_.
          1. Set _candidateDays_ to _candidateDays_ + _sign_.
        1. Return ! CreateDateDurationRecord(_years_, _months_, _weeks_, _days_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-nonisocalendardatetoiso" type="abstract operation">
      <h1>
        NonISOCalendarDateToISO (
          _calendar_: a calendar type that is not *"iso8601"*,
          _fields_: a Calendar Fields Record,
          _overflow_: ~constrain~ or ~reject~,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It converts _fields_, which represents either a date or a year and month in the built-in calendar identified by _calendar_, to a corresponding representative date in the ISO 8601 calendar, subject to overflow correction specified by _overflow_.
          For ~reject~, values that do not form a valid date cause an exception to be thrown, as described below.
          For ~constrain~, values that do not form a valid date are clamped to their respective valid range.
        </dd>
      </dl>
      <p>Like RegulateISODate, the operation throws a *RangeError* exception when _overflow_ is ~reject~ and the date described by _fields_ does not exist.</p>
      <p>Clamping an invalid date to the correct range when _overflow_ is ~constrain~ is a behaviour specific to each calendar other than *"iso8601"*, but all calendars follow this guideline.</p>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-nonisocalendardatetoiso" title></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: _fields_.[[Year]], _fields_.[[Month]], and _fields_.[[Day]] are not ~unset~.
        1. If _fields_.[[MonthCode]] is not ~unset~, then
          1. Perform ? ConstrainMonthCode(_calendar_, _fields_.[[Year]], _fields_.[[MonthCode]], _overflow_).
        1. Let _daysInMonth_ be CalendarDaysInMonth(_calendar_, _fields_.[[Year]], _fields_.[[Month]]).
        1. If _fields_.[[Day]] > _daysInMonth_, then
          1. If _overflow_ is ~reject~, throw a *RangeError* exception.
          1. Let _day_ be _daysInMonth_.
        1. Else,
          1. Let _day_ be _fields_.[[Day]].
        1. Return ? CalendarIntegersToISO(_calendar_, _fields_.[[Year]], _fields_.[[Month]], _day_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-nonisomonthdaytoisoreferencedate" type="implementation-defined abstract operation">
      <h1>
        NonISOMonthDayToISOReferenceDate (
          _calendar_: a calendar type that is not *"iso8601"*,
          _fields_: a Calendar Fields Record,
          _overflow_: ~constrain~ or ~reject~,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to convert _fields_, which represents a calendar date without a year (i.e., month code and day pair, or equivalent) in the built-in calendar identified by _calendar_, to a corresponding reference date in the ISO 8601 calendar as described below, subject to overflow correction specified by _overflow_.
          For ~reject~, values that do not form a valid date cause an exception to be thrown.
          For ~constrain~, values that do not form a valid date are clamped to their respective valid range as in CalendarDateToISO.
        </dd>
      </dl>
      <p>
        The fields of the returned ISO Date Record represent a reference date in the ISO 8601 calendar that, when converted to _calendar_, corresponds to the month code and day of _fields_ in an arbitrary but deterministically chosen reference year.
        The reference year is almost always 1972 (the first ISO 8601 leap year after the epoch), with exceptions for calendars where some dates (e.g. leap days or days in leap months) didn't occur during that ISO 8601 year.
        These exceptions are listed in <emu-xref href="#iso-reference-years"></emu-xref>.
      </p>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-nonisomonthdaytoisoreferencedate" title></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: _fields_.[[Month]] and _fields_.[[Day]] are not ~unset~.
        1. Assert: If _fields_.[[MonthCode]] is ~unset~, _fields_.[[Year]] is not ~unset~.
        1. Let _monthCode_ be _fields_.[[MonthCode]].
        1. If _calendar_ is *"chinese"* or *"dangi"*, then
          1. NOTE: This special case handles combinations of month and day that theoretically could occur but are not known to have occurred historically and cannot be accurately calculated to occur in the future, even if it may be possible to construct a PlainDate with such combinations due to inaccurate approximations. This is explicitly mentioned here because as time goes on, these dates may become known to have occurred historically, or may be more accurately calculated to occur in the future.
          1. Let _daysInMonth_ be 30.
          1. If _fields_.[[Day]] > _daysInMonth_, then
            1. If _overflow_ is ~reject~, throw a *RangeError* exception.
            1. Let _day_ be _daysInMonth_.
          1. Else,
            1. Let _day_ be _fields_.[[Day]].
          1. If _fields_.[[Year]] is not ~unset~, then
            1. [declared="isoDate"] If there exists no combination of inputs such that ! CalendarIntegersToISO(_calendar_, _fields_.[[Year]], ..., ...) would return an ISO Date Record _isoDate_ for which ISODateWithinLimits(_isoDate_) is *true*, throw a *RangeError* exception.
            1. NOTE: The above step exists so as not to require calculating whether the month and day described in _fields_ exist in user-provided years arbitrarily far in the future or past.
            1. If _monthCode_ is ~unset~, then
              1. Let _fieldsISODate_ be ! CalendarIntegersToISO(_calendar_, _fields_.[[Year]], _fields_.[[Month]], _day_).
              1. Set _monthCode_ to NonISOCalendarISOToDate(_calendar_, _fieldsISODate_).[[MonthCode]].
          1. Let _row_ be the row in <emu-xref href="#iso-reference-years"></emu-xref> with a value matching _calendar_ in the "Calendar Type" column and a value in the "Month Code" column matching _monthCode_.
          1. If the "Reference Year (Days 1-29)" column of _row_ is "‚Äî", or _day_ = 30 and the "Reference Year (<emu-not-ref>Day</emu-not-ref> 30)" column of _row_ is "‚Äî", then
            1. If _overflow_ is ~reject~, throw a *RangeError* exception.
            1. Set _monthCode_ to CreateMonthCode(! ParseMonthCode(_monthCode_).[[MonthNumber]], *false*).
        1. Else,
          1. If _fields_.[[Year]] is not ~unset~, then
            1. If there exists no combination of inputs such that ! CalendarIntegersToISO(_calendar_, _fields_.[[Year]], ..., ...) would return an ISO Date Record _isoDate_ for which ISODateWithinLimits(_isoDate_) is *true*, throw a *RangeError* exception.
            1. If _monthCode_ is not ~unset~, then
              1. Set _monthCode_ to ? ConstrainMonthCode(_calendar_, _fields_.[[Year]], _monthCode_, _overflow_).
            1. Let _daysInMonth_ be CalendarDaysInMonth(_calendar_, _fields_.[[Year]], _fields_.[[Month]]).
          1. Else,
            1. Assert: _monthCode_ is not ~unset~.
            1. Let _daysInMonth_ be the maximum number of days in the month described by _monthCode_ in any year.
          1. If _fields_.[[Day]] > _daysInMonth_, then
            1. If _overflow_ is ~reject~, throw a *RangeError* exception.
            1. Let _day_ be _daysInMonth_.
          1. Else,
            1. Let _day_ be _fields_.[[Day]].
          1. If _monthCode_ is ~unset~, then
            1. Let _fieldsISODate_ be ! CalendarIntegersToISO(_calendar_, _fields_.[[Year]], _fields_.[[Month]], _day_).
            1. Set _monthCode_ to NonISOCalendarISOToDate(_calendar_, _fieldsISODate_).[[MonthCode]].
        1. Let _row_ be the row in <emu-xref href="#iso-reference-years"></emu-xref> with a value matching _calendar_ in the "Calendar Type" column and a value in the "Month Code" column matching _monthCode_ (or "any" or "others" if there is no row matching _monthCode_ exactly).
        1. Assert: _monthCode_ and _day_ do not match an entry in _row_ that is "‚Äî".
        1. Let _referenceYear_ be the ISO reference year for _monthCode_ and _day_ as described in _row_.
        1. Return the latest possible ISO Date Record _isoDate_ such that _isoDate_.[[Year]] = _referenceYear_ and NonISOCalendarISOToDate(_calendar_, _isoDate_) returns a Calendar Date Record whose [[MonthCode]] and [[Day]] field values respectively equal _monthCode_ and _day_.
      </emu-alg>

      <emu-table id="iso-reference-years">
        <emu-caption>ISO Reference Years</emu-caption>
        <table>
          <thead>
            <tr>
              <th>Calendar Type</th>
              <th>Month Code</th>
              <th>Reference Year (Days 1‚Äì29)</th>
              <th>Reference Year (<emu-not-ref>Day</emu-not-ref> 30)</th>
            </tr>
          </thead>
          <tr>
            <td>*"buddhist"*, *"gregory"*, *"indian"*, *"japanese"*, *"persian"*, *"roc"*</td>
            <td>any</td>
            <td colspan="2">Any day including 31: 1972</td>
          </tr>
          <tr>
            <td rowspan="24">*"chinese"*, *"dangi"*</td>
            <td>M01</td>
            <td>1972</td>
            <td>1970</td>
          </tr>
          <tr>
            <td>M01L</td>
            <td>‚Äî</td>
            <td>‚Äî</td>
          </tr>
          <tr>
            <td>M02</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td>M02L</td>
            <td>1947</td>
            <td>‚Äî</td>
          </tr>
          <tr>
            <td>M03</td>
            <td>1972</td>
            <td>*"chinese"*: 1966<br>
              *"dangi"*: 1968</td>
          </tr>
          <tr>
            <td>M03L</td>
            <td>1966</td>
            <td>1955</td>
          </tr>
          <tr>
            <td>M04</td>
            <td>1972</td>
            <td>1970</td>
          </tr>
          <tr>
            <td>M04L</td>
            <td>1963</td>
            <td>1944</td>
          </tr>
          <tr>
            <td>M05</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td>M05L</td>
            <td>1971</td>
            <td>1952</td>
          </tr>
          <tr>
            <td>M06</td>
            <td>1972</td>
            <td>1971</td>
          </tr>
          <tr>
            <td>M06L</td>
            <td>1960</td>
            <td>1941</td>
          </tr>
          <tr>
            <td>M07</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td>M07L</td>
            <td>1968</td>
            <td>1938</td>
          </tr>
          <tr>
            <td>M08</td>
            <td>1972</td>
            <td>1971</td>
          </tr>
          <tr>
            <td>M08L</td>
            <td>1957</td>
            <td>‚Äî</td>
          </tr>
          <tr>
            <td>M09</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td>M09L</td>
            <td>2014</td>
            <td>‚Äî</td>
          </tr>
          <tr>
            <td>M10</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td>M10L</td>
            <td>1984</td>
            <td>‚Äî</td>
          </tr>
          <tr>
            <td>M11</td>
            <td>1972</td>
            <td>1970</td>
          </tr>
          <tr>
            <td>M11L</td>
            <td>Days 1‚Äì10: 2033<br>
              Days 11‚Äì29: 2034</td>
            <td>‚Äî</td>
          </tr>
          <tr>
            <td>M12</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td>M12L</td>
            <td>‚Äî</td>
            <td>‚Äî</td>
          </tr>
          <tr>
            <td rowspan="2">*"coptic"*, *"ethioaa"*, *"ethiopic"*</td>
            <td>M13</td>
            <td>Days 1‚Äì5: 1972<br>
              <emu-not-ref>Day</emu-not-ref> 6: 1971<br>
              Days 7‚Äì29: ‚Äî</td>
            <td>‚Äî</td>
          </tr>
          <tr>
            <td>others</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td rowspan="4">*"hebrew"*</td>
            <td>M02</td>
            <td>1972</td>
            <td>1971</td>
          </tr>
          <tr>
            <td>M03</td>
            <td>1972</td>
            <td>1971</td>
          </tr>
          <tr>
            <td>M05L</td>
            <td colspan="2">1970</td>
          </tr>
          <tr>
            <td>others</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td rowspan="2">*"islamic-civil"*, *"islamic-tbla"*</td>
            <td>M12</td>
            <td>1972</td>
            <td>1971</td>
          </tr>
          <tr>
            <td>others</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td rowspan="12">*"islamic-umalqura"*</td>
            <td>M01</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td>M02</td>
            <td>1972</td>
            <td>1970</td>
          </tr>
          <tr>
            <td>M03</td>
            <td>1972</td>
            <td>1971</td>
          </tr>
          <tr>
            <td>M04</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td>M05</td>
            <td>1972</td>
            <td>1971</td>
          </tr>
          <tr>
            <td>M06</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td>M07</td>
            <td>1972</td>
            <td>1969</td>
          </tr>
          <tr>
            <td>M08</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td>M09</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td>M10</td>
            <td>1972</td>
            <td>1970</td>
          </tr>
          <tr>
            <td>M11</td>
            <td colspan="2">1972</td>
          </tr>
          <tr>
            <td>M12</td>
            <td>1972</td>
            <td>1971</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sup-calendarextrafields" type="abstract operation">
      <h1>
        CalendarExtraFields (
          _calendar_: a calendar type,
          _fields_: a List of values from the "Enumeration Key" column of <emu-xref href="#table-calendar-fields-record-fields"></emu-xref>,
        ): a List of values from the "Enumeration Key" column of <emu-xref href="#table-calendar-fields-record-fields"></emu-xref>
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It characterizes calendar-specific fields that are relevant for the provided _fields_ in the built-in calendar identified by _calendar_.</dd>
      </dl>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-calendarextrafields" title></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. If _fields_ contains an element equal to ~year~ and CalendarSupportsEra(_calendar_) is *true*, then
          1. Return ¬´ ~era~, ~era-year~ ¬ª.
        1. Return an empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-nonisofieldkeystoignore" type="abstract operation">
      <h1>
        NonISOFieldKeysToIgnore (
          _calendar_: a calendar type that is not *"iso8601"*,
          _keys_: a List of values from the "Enumeration Key" column of <emu-xref href="#table-calendar-fields-record-fields"></emu-xref>,
        ): a List of values from the "Enumeration Key" column of <emu-xref href="#table-calendar-fields-record-fields"></emu-xref>
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to determine which calendar date fields changing any of the fields named in _keys_ can potentially conflict with or invalidate, for the given _calendar_.
          A field always invalidates at least itself.
        </dd>
      </dl>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-nonisofieldkeystoignore" title></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _ignoredKeys_ be a copy of _keys_.
        1. For each element _key_ of _keys_, do
          1. If _key_ is ~month~, append ~month-code~ to _ignoredKeys_.
          1. If _key_ is ~month-code~, append ~month~.
          1. If _key_ is one of ~era~, ~era-year~, or ~year~ and CalendarSupportsEra(_calendar_) is *true*, then
            1. Append ~era~, ~era-year~, and ~year~ to _ignoredKeys_.
          1. If _key_ is one of ~day~, ~month~, or ~month-code~ and CalendarHasMidYearEras(_calendar_) is *true*, then
            1. Append ~era~ and ~era-year~ to _ignoredKeys_.
        1. NOTE: While _ignoredKeys_ can have duplicate elements, this is not intended to be meaningful. This specification only checks whether particular keys are or are not members of the list.
        1. Return _ignoredKeys_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-nonisoresolvefields" type="implementation-defined abstract operation">
      <h1>
        NonISOResolveFields (
          _calendar_: a calendar type that is not *"iso8601"*,
          _fields_: a Calendar Fields Record,
          _type_: ~date~, ~year-month~, or ~month-day~,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to validate that _fields_ (which describes a date or partial date in the built-in calendar identified by _calendar_) is sufficiently complete to satisfy _type_ and not internally inconsistent, and mutates _fields_ into acceptable input for CalendarDateToISO or CalendarMonthDayToISOReferenceDate by merging data that can be represented in multiple forms into standard fields and removing redundant fields (for example, merging [[Era]] and [[EraYear]] into [[Year]]).
        </dd>
      </dl>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-nonisoresolvefields" title></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _needsYear_ be *false*.
        1. If _type_ is ~date~ or _type_ is ~year-month~, set _needsYear_ to *true*.
        1. If _fields_.[[MonthCode]] is ~unset~, set _needsYear_ to *true*.
        1. If _fields_.[[Month]] is not ~unset~, set _needsYear_ to *true*.
        1. Let _needsDay_ be *false*.
        1. If _type_ is ~date~ or _type_ is ~month-day~, set _needsDay_ to *true*.
        1. If _needsYear_ is *true*, then
          1. If _fields_.[[Year]] is ~unset~, then
            1. If CalendarSupportsEra(_calendar_) is *false*, throw a *TypeError* exception.
            1. If _fields_.[[Era]] is ~unset~ or _fields_.[[EraYear]] is ~unset~, throw a *TypeError* exception.
        1. If CalendarSupportsEra(_calendar_) is *true*, then
          1. If _fields_.[[Era]] is not ~unset~ and _fields_.[[EraYear]] is ~unset~, throw a *TypeError* exception.
          1. If _fields_.[[EraYear]] is not ~unset~ and _fields_.[[Era]] is ~unset~, throw a *TypeError* exception.
        1. If _needsDay_ is *true* and _fields_.[[Day]] is ~unset~, throw a *TypeError* exception.
        1. If _fields_.[[Month]] is ~unset~ and _fields_.[[MonthCode]] is ~unset~, throw a *TypeError* exception.
        1. If CalendarSupportsEra(_calendar_) is *true* and _fields_.[[EraYear]] is not ~unset~, then
          1. Let _canonicalEra_ be CanonicalizeEraInCalendar(_calendar_, _fields_.[[Era]]).
          1. If _canonicalEra_ is *undefined*, throw a *RangeError* exception.
          1. Let _arithmeticYear_ be CalendarDateArithmeticYearForEraYear(_calendar_, _canonicalEra_, _fields_.[[EraYear]]).
          1. If _fields_.[[Year]] is not ~unset~, and _fields_.[[Year]] ‚â† _arithmeticYear_, throw a *RangeError* exception.
          1. Set _fields_.[[Year]] to _arithmeticYear_.
        1. Set _fields_.[[Era]] to ~unset~.
        1. Set _fields_.[[EraYear]] to ~unset~.
        1. NOTE: _fields_.[[Era]] and _fields_.[[EraYear]] are erased in order to allow a lenient interpretation of out-of-bounds values, which is particularly useful for consistent interpretation of dates in calendars with regnal eras.
        1. If _fields_.[[MonthCode]] is not ~unset~, then
          1. If IsValidMonthCodeForCalendar(_calendar_, _fields_.[[MonthCode]]) is *false*, throw a *RangeError* exception.
          1. If _fields_.[[Year]] is not ~unset~, then
            1. If YearContainsMonthCode(_calendar_, _fields_.[[Year]], _fields_.[[MonthCode]]) is *true*, let _constrainedMonthCode_ be _fields_.[[MonthCode]]; else let _constrainedMonthCode_ be ! ConstrainMonthCode(_calendar_, _fields_.[[Year]], _fields_.[[MonthCode]], ~constrain~).
            1. Let _month_ be MonthCodeToOrdinal(_calendar_, _fields_.[[Year]], _constrainedMonthCode_).
            1. If _fields_.[[Month]] is not ~unset~ and _fields_.[[Month]] ‚â† _month_, throw a *RangeError* exception.
            1. Set _fields_.[[Month]] to _month_.
            1. NOTE: _fields_.[[MonthCode]] is intentionally not overwritten with _constrainedMonthCode_. Pending the "overflow" parameter in CalendarDateToISO or CalendarMonthDayToISOReferenceDate, a month code not occurring in _fields_.[[Year]] may cause that operation to throw. However, if _fields_.[[Month]] is present, it must agree with the constrained month code.
        1. Assert: _fields_.[[Era]] and _fields_.[[EraYear]] are ~unset~.
        1. Assert: If _needsYear_ is *true*, _fields_.[[Year]] is not ~unset~.
        1. Assert: _fields_.[[Month]] is not ~unset~.
        1. Assert: If _needsDay_ is *true*, _fields_.[[Day]] is not ~unset~.
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
